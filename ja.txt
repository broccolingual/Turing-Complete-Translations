=== levels/Spacial Invasion ===

$19967210826470 レーザーは,他のレーザーがすでに撃たれていないときにしか撃てないことに注意してください.
$16294185981398 貨物船は宇宙ネズミがはびこるようになった.
$11505369795084 [color=#e49f44][url=the_robot]ロボットのページ[/url][/color] で,プログラミングの方法を確認してください.プログラムエディタにもそのページへのリンクがあります.
$10515630949378 あなたのマシンを私たちの先進的なロボットに接続し,レーザーで宇宙ネズミを撃つようにプログラムしてください.


=== components/OutputQword ===

$43552728118031 出力


=== components/Output 1 ===

$12242923444593 出力


=== levels/RAM ===

$17967666262990 このテストでは,まず入力から32回コピーして,これらの値を保存します.32 個の値を読み込んだら,取得したのと同じ順序で出力してください.すべての入力を読み込む前に出力すると,レベルは不合格になります.
$13520918982355 RAMブロックを追加し,コンピュータが256バイトのメモリを追加でアドレス指定できるようにします.RAM内の256バイトのうち,どのバイトをアドレスしているかを決める方法が必要です.レジスタを選択し,その値が常にRAMのアドレスを選択するように配線してください.後でRAMにロードまたはセーブする場合,まずRAMアドレスをこのレジスタにコピーする必要があります.


=== levels/byte_less_i ===

$16755383054285 [center]最初の入力が2番目の入力より小さいかどうかを判断する.[/center]
$19006843777401 1番目の入力が2番目の入力より小さいとき, [ON] を出力する回路を作成する. バイトは [color=#dd6576]符号付き[/color] であると解釈してください.
$46083799633716 {input_1} は {input_2} より小さいか?


=== ui/toggles/level_map ===

$71951682957395 レベルマップ


=== ui/state_ui/title_screen/exit ===

$12639868461113 終了


=== misc/button_next ===

$50213503063080 次のティック (ホットキー: F5)


=== levels/saving_bytes ===

$10633476398156
バイトを [SAVE] または [LOAD] できる回路を作成する.

最初の入力ビットが[ON]のとき、メモリを[LOAD]して出力に送る.
2番目の入力ビットが[ON]のとき、入力バイトを[SAVE]する.

$15510981129613 LOAD
$13502950630653
[color=#ff9800]None
0
0[/color]
$19109563882664 DON'T LOAD
$16372198430230 SAVE
$11467279617581 SAVE
$15498440508450 Do nothing
$10080722944246 DON'T SAVE
$18873598212433 LOAD
$15582618410991 LOAD and SAVE


=== levels/maze ===

$13225915898937
If you choose to go on to the rest of the levels I will teach you about ram, the stack and function calls and you will get to solve more interesting challenges like this one.
		
But first you would have to build a better computer. [color=#e49f44]OVERTURE[/color] was good as a first machine, but it is clumsy and programs get very messy. To solve the challenges I have for you without pulling all your hair out, you will need something more expressive, the [color=#e49f44]LEG[/color] architecture.
$17275059688693 Congratulations, you won the competition! An amazing achievement!
$13741358519166 The fabled maze. If you solve it you win the competition!
$11103446544344 On the other hand, you could also retire, be proud and enjoy your reward of not being eaten.
$19331074553774
Write an algorithm that gets the robot from the start to the exit. 

This level is hard, you probably want to write down the pseudocode for your algorithm before you implement it.

Use [color=#e63e5b][url=maze]this hint[/url][/color] if you get stuck.

[tip]Remember you can't use immedate values larger than 63, a common mistake is to try to jump to a label further down than the 63rd byte.[/tip]


=== misc/level_gate_component_icon ===

$83440578602427 アンロックされたコンポーネント


=== levels/any_doubles ===

$16587030847545 私たちは技術的に進んでいるので,機械で靴下をたたむことができます.しかし残念ながら,靴下のペアを検出する回路が機械で壊れてしまったのです.
$14373083988184
このレベルには4つの入力があります. 
2つ以上が [ON] の時に出力が [ON] になります.

[tip]このレベルでは考え過ぎないように.[/tip]


=== levels/byte_constant ===

$12641789008694 常に164を出力する回路を作成する.


=== components/Output 1 + 1B ===

$81929942356043 出力


=== levels/call_ret ===

$15840165316981
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.

$19416009887091
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=termonology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$19369640789869 Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.
$15463931654475 [center]Add "call" and "ret" instructions[/center]


=== levels/push_pop2 ===

$10062117579269 スタックをコンピュータに追加する
$14685569269160
このレベルでは,スタックをコンピュータに追加し,そのレベルを解決するプログラムを書くことになります.
入力が0のとき,スタックから値を [color=#e49f44]ポップ[/color] して出力しなければなりません.入力が0でないときは [color=#e49f44]プッシュ[/color] してスタックに格納します.
$18561605111721 プッシュ {input} をスタックに積む
$59658696292688 ポップ {value} をスタックから除く


=== levels/odd_ticks ===

$18510295620397 偶数のTickで[OFF]、奇数のTickで[ON]を出力する.
$16987046679863 前のレベルでは,循環的な依存関係を実現しない方法を学びました.今回は、1つの例外を学びます.
$16037516781370
ゲーム内の四角いピンは,同じティック内の出力に影響を与えることはありません.したがって,循環的な依存関係が発生することはありません.
	
	[img]dialogue/delay_buffer.png[/img]
$17588119878416
Delay Lineはそれ自身の入力に依存することが許されています.これは,その入力が次のティックまで回路の残りの部分に影響を与えないためです.
	
[img]dialogue/delay_buffer.png[/img]


=== main_scripts/leg_level ===

$70383685548547 REG 
$53021804895845 ANDi
$69956969985790 ORi
$85913831661289 IF_LESS
$11144256835662 XORi
$61412773713567 SUB
$52344899983501 IF_LESS_OR_EQUAL
$89945092889418 SUBi
$89011349770597 NOT
$71559031724238 IF_NOT_EQUAL
$40520283279584 XOR
$71204580217527 NOTi
$71195301111400 ADDi
$98178474649432 IF_GREATER_OR_EQUAL
$68187490877029 IF_EQUAL
$50722296752142 INPUT
$43723329256095 REG {nr}
$37810243909140 COUNTER
$44009845985661 ADD
$68666991962246 OR
$79492115258673 IF_GREATER
$64519909700148 AND
$49810487048038 COUNTER
$18236360532765 OUTPUT


=== ui/options/Robot Controls ===

$58799802152286 ロボット操作


=== misc/solution_option ===

$21618236951146 解決策を見る


=== misc/run_fast ===

$49363678936533 ティックの刻みを早くする (右クリック: ターゲットスピードの変更)


=== misc/delay_overlay ===

$85430022417382 ディレイオーバーレイの表示


=== misc/options ===

$49251062339706 設定


=== levels/turing_complete ===

$15326252036920 Before, only code could influence memory, now memory must influence code. With the addition of conditional logic, our computer can run any algorithm, and calculate anything calculable.
$16583885726240 Yes you did it! I thought you were just this odd looking hairless ape creature, but you actually built a real computer! Amazing.
$10510746154639 At tick 1 the program should load address 1.
$10317244906317 No program found
$14587485007736 Until this point all possible programs have been confined to running in order byte by byte.
$19649119273248
The final thing we need to add is a mechanism for changing the program counter through [INSTRUCTIONS] when certain conditions are met.

When the two largest bits are [ON][ON], we are in condition mode. In condition mode, the value in REG 3 is compared against the conditions defined by the lowest 3 bits in the instruction. If the condition is true, we overwrite the counter to the value in REG 0.
Conditionally changing the counter means we can skip [INSTRUCTIONS] based on conditions or have [INSTRUCTIONS] run in a loop.

Conditions:
[OFF] [OFF] [OFF] Never
[OFF] [OFF] [ON] If [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] If [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] If [color=#e49f44]REG 3[/color] ≤ 0 
[ON] [OFF] [OFF] Always
[ON] [OFF] [ON] If [color=#e49f44]REG 3[/color] ≠ 0 
[ON] [ON] [OFF] If [color=#e49f44]REG 3[/color] ≥ 0
[ON] [ON] [ON] If [color=#e49f44]REG 3[/color] > 0

These conditions correspond to the condition component that was saved in the component factory.


=== components/Input 1 ===

$12746117288689 入力


=== levels/Second Tick ===

$14355963067874 2Tick目のみ[ON]を出力する.
$17526582195506 ご存知のように,このテストはコンピュータの機能を構築することに集約されます.
$15726318553190 これが,後からあなたを食べない最大の理由です.
$19277843280528
 [color=#b72d41][b]TIP:[/b][/color] 
 コンポーネントとそのピンをダブルクリック
 することで一緒に選択することができます.
$15296208528991 Species that are capable of finishing are considered sentient by law.


=== levels/divide ===

$16412715945615 [center]2つの数値を割る[/center]
$14525870461271
Integer divide two numbers to find the quotient and the remainder. Consider the fraction 7/3. 3 goes into 7 2 times and 1 is left over. Here 2 is called the [color=#e49f44]quotient[/color] and 1 is called the [color=#e49f44]remainder[/color].
In this exercise, you are first given the numerator (7 in the example) and then the denominator (3) and you are then expected to output the quotient (2) and then the remainder (1).
$76454016047920 {numerator}/{denominator} = {quotient}, remainder {remainder}


=== levels/buffer ===

$10260210687588 [center]テスト 2: Left input is [img]dialogue/on.png[/img], right output should be [img]dialogue/on.png[/img].[/center]
$13309706297402 [center]テスト 3: Right input is [img]dialogue/on.png[/img], left output should be [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Make sure [img]dialogue/on.png[/img] can only flow from left to right.[/center]
$18349621873762 [center]テスト 1: Both inputs are [img]dialogue/off.png[/img], neither side should turn [img]dialogue/on.png[/img].[/center]
$15504762262759
このレベルは,2つの特別なコンポーネントから始まります.これらは同時に入力と出力として機能します.

信号が左から右にしか流れないことを確認してください.以下の3つのテストがあります.

[b]テスト 1[/b]: 両側とも［OFF］になる.

[b]テスト 2[/b]: 左側の入力が [ON] になり,右側の入力が [ON] になる.

[b]テスト 3[/b]: 右側の出力が[ON]になり,左側が[OFF]になる.


=== components/Output 4 ===

$90190739202646 出力


=== misc/select_color ===

$97461374731210 ワイヤーの色


=== levels/component_factory ===

$17077079648771 コンポーネントの追加,名前の変更,削除はレベルセーブ方式で行うことができます.
$19551383617326
コンポーネントファクトリーへようこそ,ここで作成した回路は,アーキテクチャレベルのコンポーネントとして使用することができます.
作成する回路はコンポーネントの動作を定義し,レイアウトはその形状を定義します.
$12516102012088 このコンポーネントはエリアを持たず,レベルでは使用できません.マップ上にコンポーネントを配置すると,エリアが与えられます.
$14712417427860 このレベルはツールであり,チャレンジではないので,好きなときにレベルマップに移動して先に進むことができます.
$15549447390000 2つの入出力コンポーネントが同じマスにある場合.2本のピンが重ならないので、カスタムコンポーネントは使えなくなります.


=== ui/state_ui/state_ui_output_bit ===

$40754755480566 出力


=== misc/instr_delete ===

$91861509153454 削除


=== misc/instruction_expand ===

$44690074039467 定義ルールを変更


=== levels/Delicious Order ===

$10160261151833 First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666 We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== levels/ai_showdown ===

$14940806461794
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678 NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012 This time he has taken over the control room and holds the captain hostage.


=== misc/ui_comment ===

$69987793052607 ワイヤーコメント (ワイヤーをクリック)


=== levels/delay_level ===

$19986989895202
All components have a delay. And in a circuit, the total delay is determined by the slowest path. This means you normally want to put things in parallel.
In this level you must prove that you understand this concept.
$11246430085016 Note, you can see the delay path by clicking the hour glass in the upper right corner.
$12817338693402 The delay of any component is ultimately derived from the delay of the nand gate, which has a delay of 2. Build a circuit with a delay of 6 and a nand cost of 5.


=== levels/push_pop ===

$78804623186243 OUTPUT
$49526452710191 DON'T POP
$58050047963238 VALUE
$30926395960020 PUSH
$19245209470436 スタックを作成する
$12227209887733 Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
$85171087236638 ENABLE
$15662660252584 Do nothing
$23726790986805 POP
$62469306234943 DON'T PUSH
$46948857059388 POP value {value} off stack
$18761197388580 In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.
$65188797398656 PUSH {value} on stack


=== levels/Tower of Radioactive Alloy ===

$13757925963562 Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686 We need you to help clean up the basement.
$35120623183961 Move from {source} to {destination}
$15855497886737
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== levels/The Product of Nibbles ===

$14622683750375 ビット 2
$14957949958941 ここでやったことは,実際には2つの4ビット数を掛け合わせたものです.代わりにバイトにスケールアップしてました.
$17331397914567 ビット 1
$19136817138607 [center]4ビットの数値の乗算[/center]
$13232094477834 ビット 3
$13549246864135 ビット 0
$15857218442751 ビット 1
$18132100348781
 [color=#b72d41][b]TIP:[/b][/color] 
 ファイルメニューの "ネストレベル" 
 を変更することで,ファクトリー内に
 ネストしたコンポーネントを作成します。
$14533861483435 4ビットの数値同士を掛け合わせると8ビットの数値になります.これを実現する回路を作りましょう。
$10430040077737 ビット 3
$10274387271390 ビット 0
$16301538038805 ビット 2
$83694551809785 {num1} と {num2} を乗算する


=== components/Input 1 Byte ===

$40943344093513 入力


=== levels/signed_negator ===

$10866019808027 For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click "+255" located in the top panel.
$10400106910274
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
例 4 negated would become -4. -9 negated would become 9.


=== levels/byte_and ===

$15885763626223 2バイトをビット単位でANDする回路を作成する.


=== ui/toggles/level_log2 ===

$91515053618360 マニュアル


=== main_scripts/functions ===

$11467644007149 カウンタ {nr}
$10533010562232 DELAY SCORE: {delay}
$87591753278764 Reg {nr}
$29169064199243 出力 {nr}
$13327741293223 入力 {nr}
$32508339206292 NAND SCORE: {nand}


=== levels/odd_number_of_signals ===

$16173829560311 最大3つのコンポーネントを用いて,奇数の入力が [ON] のときのみ [ON] を出力します.
$85589489148198 使用したコンポーネント\n{nr} of 3
$18288998816979 このレベルには行き詰まったときに使える [color=#e63e5b][url=odd_number]ヒント[/url][/color] があります.


=== levels/or_gate_3 ===

$15448906128695 3入力のORゲートを作成する.


=== ui/state_ui/title_screen/play ===

$82533529573294 プレイ


=== nim/backend_lib/level_list ===

$58391129129347 Registers (レジスタ)
$45936227746026 Counter (カウンタ)
$12946639957230 NOT Gate
$16881141174140 Binary Racer (二進数レーサー)
$37136208388559 SR Latch
$32191988336459 Saving Gracefully
$59136962133320 Logic Engine (論理エンジン)
$30920780473397 Circular Dependency
$83321010943153 Counting Signals (信号のカウント)
$58769021955965 3 bit decoder (3ビットデコーダー)
$78673715398197 Immediate Values (即値)
$49679174636208 Byte XOR
$40356575891647 Byte OR
$44393538021725 Calibrating Laser Cannons (レーザーキャノンの校正)
$87426564872318 Divide (除算)
$61228036919534 Tower of Radioactive Alloy (放射性合金の塔)
$24593959732668 Signed negator
$19487493622742 Half Adder (半加算器)
$26705128002562 Conditions
$94163943335575 The Sandbox
$64662599400870 Bit Inverter (ビット反転)
$27566801288091 Component Factory
$14193654974055 Signed Less
$14522992467987 OR Gate
$74096060570427 Wide Instructions
$30630492494839 Byte NOT
$11457737665157 Wire Spaghetti
$59485174474959 Delicious Order (おいしい注文)
$85514901357243 Adding Bytes (バイトの加算)
$98013649264532 Stack
$35790581910835 Second Tick
$94979277765051 Robot Racing
$13303326918621 NAND Gate
$16463062897451 Crude Awakening (粗野な目覚め)
$77495536880911 NOR Gate
$61466151084505 Spacial Invasion (宇宙からの侵略)
$20858506932774 AND Gate
$28827008935802 The Lab
$92696642439976 AI Showdown (AI対決)
$62326481348276 The Maze
$74512388889988 Arithmetic Engine (演算処理エンジン)
$50884376329157 Little Box (小さな箱)
$70651296323768 XOR Gate
$31140969090253 Planet Names (惑星の名称)
$42873691377272 Add 5
$36114120875026 Storage cracker
$45773199639367 Odd ticks
$17198602105978 Unsigned Less
$43018398941741 Always On
$68155633878444 Delay
$15420972347773 RAM
$40549516333234 Byte AND
$33343343932901 Turing Complete (チューリング完全)
$95989050249094 Bigger AND Gate (より大きなANDゲート)
$69830943995038 One Way (一つの道)
$63331549672739 Opcodes (オペコード)
$87626070552799 Full Adder (全加算器)
$13219675195117 ODD Number of Signals
$62167495140389 Shift
$28985439820134 The Product of Nibbles
$94896856420525 XNOR Gate
$25805639594354 Program (プログラム)
$57870391153000 Immediate Values (即値)
$56272944092958 Further Delayed Lines
$96825664933181 Unseen Fruit (見えない果実)
$86717899742637 Saving Bytes (バイトの保存)
$53092952738479 Input Selector (入力セレクタ)
$70993791338383 XOR
$77453667419150 Instruction Decoder (命令デコーダー)
$17750429607702 1 bit decoder (1ビットデコーダー)
$79570913613529 Double the Number (数を2倍に)
$59939822079116 Negative Numbers (負の数)
$96898830278153 Byte Constant
$50992859018018 Switch
$49328023903824 Equality
$74292408260828 Calculations
$45480765206717 Conditionals
$71126291573555 Double Trouble
$33132016601448 PUSH and POP
$75225719777307 Water World
$64615090872051 Functions
$84208736840052 Masking Time
$91954159574064 Bigger OR Gate
$36221227239949 Dancing Machine


=== ui/options/Controls ===

$53266310714298 コントロール


=== levels/3_decoder ===

$19231618567710 With 3 bits of input there are 8 combinations. Make a circuit that selects 1 output for each of the 8 combinations. No more or less than 1 bit should be [ON] at a time.
$14293122338496 We had our intern add a "disable" bit to this component. We were tired of looking at him running in circles and were looking for other pointless and tedious tasks to give him.


=== levels/test_lab ===

$11038144815919
This level uses programs to test your circuits. When the programs are run, this level checks if the "watched state" behaves the way you expect.

The lab has 2 extra keywords.

The [color=#c54d5e]expect[/color] keyword is used to describe what a value a memory address should hold next tick.

The first number after [color=#c54d5e]expect[/color] is index in the watched state, the second number is the expected value. The watched state indexes are the order the components are connected up in to the program component.

[img]dialogue/watched_state.png[/img]

例:
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

Here, the first line says that we expect the 2nd watched state slot to hold a value of 4 after the next tick.

All watched state is checked against expectations at every tick. All watched state is expected to be 0 at the start of the program, and expectations for memory components only change as you specifically change the expectations. The one exception are counters, these are naturally expected to increment each tick.

The second special keyword for the lab is [color=#c54d5e]set_input[/color]. With this you can control the input of the computer:
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

You can at any time also (re)import example tests by clicking below:
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]

$15446846177093 Welcome to the lab. Like the component factory, this is not a normal level but a tool.
$16072814175447 Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about circuits, when you are in the middle of solving a programming problem. It is tempting to apply a quick circuit fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!


=== levels/オペコードs ===

$19693461238792 Set the counter increment to 4
$38976231780455 Watched state {nr} should point to a register or custom component with a register inside
$20916717363300 Watched state {nr} should point to the output
$18189600217529 Implement the オペコード instructions
$13450117997204 Add a counter to the circuit
$77044880242883 Watched state {nr} should point to the counter
$13870568875751 Create a new schematic and add a program with 4 byte output
$10303603301757
Implement the following オペコードs:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The オペコード NOT ignores the second 引数.
$17495651785164 Add 6 registers to the map


=== levels/Nor GATE ===

$11362258372706
地球上のほとんどの生物は攻撃的で,集中することを知りません.

成功するためには,物事を壊さないようにしながら,論理的な思考を身につける必要があります.


=== misc/run ===

$67345621265845 Run ticks (ホットキー: F6)


=== levels/byte_not ===

$14196498898485 道具の製作と使用は,知能を発達させる進化の初期段階において重要な鍵を握っています.
$12982025748137 バイト入力の各ビットを "NOT "とする.
$10294533225655 脳の大きさが知能の主な予測因子であるという以前のモデルは,甘かったのです.
$14958585065722 ですから,生物の腕の数は,明らかに知能の予測因子となります.あなたの惑星には,あなたの4倍の腕を持つ海の生き物がいて,彼らはテストで良い結果を出していることをご存知ですか?


=== levels/Storage cracker ===

$11910674853271
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673 You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== levels/constants ===

$17098439090371
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== misc/circuit_draw ===

$59836059268386 新しい回路 (ホットキー: Alt & drag)


=== misc/watchable_state ===

$58678516111149 監視状態の編集


=== levels/program ===

$16693098943939
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479 The program is still outputting the first instruction. Did you hook up a counter?


=== levels/wide_instrucitons ===

$13709034294291 Save on even tick, output both bytes on odd ticks
$17693995237077 Output both bytes
$19068760748550 Output 0 on even ticks
$65009239162932 The correct outputs were {a} and {b}
$19203973423116 Create a device that saves the program output on even ticks, and outputs both bytes on odd ticks.
$17409169138995 Save the byte


=== components/Input 3 ===

$70689623552857 入力


=== levels/Arithmetic Engine ===

$16434409050195
回路に足し算と引き算を追加する.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810 We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837 Input: 
$11201813578269 Output: 


=== levels/byte_equal ===

$17156565273196 両方の入力が同じ場合,[ON]を出力する.


=== levels/Calculations ===

$14458828731919
Time to merge in the "Arithmetic Engine" circuit you made previously with the register circuit. The calculation circuit was saved in the component factory and can now be added as a component. If you forgot which pin does what, check the circuit in the component factory.

Use the decoder you built to figure out if we should copy between registers or do calculations. Here are the 4 different modes again:
[OFF][OFF] Immediate
[ON][OFF] Copy
[OFF][ON] Calculate
[ON][ON] Condition

For this level you only have to worry about the copy and calculate mode, check [INSTRUCTIONS] in the top panel for the details. When in calculate mode, take [color=#e49f44]REG 1[/color] and [color=#e49f44]REG 2[/color] as inputs, and save the result in [color=#e49f44]REG 3[/color].

[tip]Don't forget the 3 bit decoder component has a disable bit.[/tip]
$13013863429580 For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== levels/Counter ===

$17701404772563 1を足す
$17940006660359 カウント
$17263901743088
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$68874699768861 {value}で上書き
$17883663978196 上書き
$19407121413983 ACTION
$10555159894041
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== components/InputQword ===

$31709565019284 入力


=== ui/options/General ===

$36195388998735 一般


=== levels/not_gate ===

$19085882338208 [b]Instruction[/b]\n右クリックで選択解除
$10042327259531 あなたはNANDゲートを解除しました.これを利用して回路を作成しましょう.
$14042842216181 前のレベルでは,回路を説明する表を作成しました.このレベルでは,表に一致する回路を作成します.
$10604720087324 [b]Instruction[/b]\n表と一致する回路を作成すする.\n左上の [i][/i] (Next tick) をクリックして入力の組み合わせをテストします.\n両方の組み合わせが正しくテストされると,レベルの達成です.
$19798729463813
NANDゲートを使って,NOTゲートを作成する

Using: [b]NAND gate[/b]
[code]INPUT 1: [OFF][ON][OFF][ON]
INPUT 2: [OFF][OFF][ON][ON]
OUTPUT:  [ON][ON][ON][OFF][/code]

Build: [b]NOT gate[/b]
[code]INPUT 1: [ON][OFF]
OUTPUT:  [OFF][ON][/code]

$18442122157391 [b]Instruction[/b]\n背景をクリックして,コンポーネントの選択を解除する
$12880883686501 [b]Instruction[/b]\n画面右上のNANDコンポーネントをクリックし、配置する
$18780831606716 [b]Instruction[/b]\n基板上でクリック＆ドラッグしてワイヤーを追加する


=== levels/byte_shift ===

$16023356915123
このレベルの目標は,最初の入力を2番目の入力で与えられた値だけ左にシフトすることです.ただし,2番目の入力が7を超えることはないものとする.

$37338672894296 {value} のビットを {amount} だけ左にシフトする.
$10598344098990 [center]最初の入力を,2番目の入力で指定された桁数だけ左にシフトする[/center]
$16216408139965
値を左に1シフトする[color=#e49f44]シフト[/color]とは,1バイト中の全てのビットを1つ左に移動させることを意味します.
例: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]


$18137790657923 In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.
$18518173140953 I recommend that you add [color=#e49f44]shift left[/color] and [color=#e49f44]shift right[/color] to your hardware for future levels.


=== misc/factory ===

$53123649343022 コンポーネントファクトリー


=== levels/registers ===

$10661964231175 I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$15888345020710
In this level you need to create a circuit which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color]. 

The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color]. 

Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$14823499195861 Open "Instructions" in the top bar
$14108238519744 Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593 Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755 出力


=== levels/xnor ===

$11090938799865 XNORとして知られている逆XORゲートを作成する.


=== levels/decoder ===

$16133643476631 The circuit you built in the "Registers" level can copy values between registers, while the "Arithmetic Engine" can do different operations on 2 inputs. But you need to be able to do both in the same circuit. To do this, build a "decoder", which will decide which mode our computer is in, based on the 2 bits we haven't used yet.
$18435544383511 CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383 COPY
$18945946395447
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$16785126425267 CALCULATION
$15440615199508 CONDITION
$12671132029272 Your circuit has been saved to the component factory.
$15105859227432 COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12068329066372 [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408 CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611 IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542 IMMEDIATE


=== levels/bit_inverter ===

$15769391111364 When "Invert" is [ON], output the opposite of "Value". Otherwise, just output "Value" as is.
$15272914096446 This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527 Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$16125025706490 Hmm, perhaps you have studied memory a little bit too well...
$13224963076378 We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/ram_block ===

$17142958857584 A OR B
$12901484249817 Can you fit 4 bytes of memory in this limited space?
$14218335256117
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$19282543476901 1
$13765566466116 DON'T SAVE
$15908016538045 VALUE
$16196915566111 0
$32676754026463 Save {value} and load
$30856781458049 Save {value}
$14259545926196 A
$12306130287676
In this level you have to build a circuit that 
can [SAVE] or [LOAD] from 4 different bytes of memory.

You are given 1 bit that determines if you are to [LOAD]. Another bit determines if you are to [SAVE] and it comes with a corresponding value.
Additionally, you have 2 address bits. 

With 2 bits, there are 4 combinations, one for each byte of memory in this level.
[i][tip]Join wires in the middle and use right angles or this will be a mess.[/tip][/i]
[i][tip]Spacebar rotates components.[/tip][/i]
$16217965518477 B
$10891070331034 B
$18084166025569 Nothing
$13082830776248 DON'T LOAD
$17473197268827 LOAD
$13555908976270 0 OR 1
$10311371309532 SAVE
$16925432534232 LOAD
$13644027370563 Load
$12933801309767 A
$12291627335021 SAVE


=== misc/score_sync ===

$76911045833478 スコア同期


=== misc/level_gate_manual_icon ===

$22002156022920 Unlocks manual entry


=== misc/level_gate_unlocks_unknown ===

$76731326010721 Unlocks something unknown


=== ui/top_bar/nand_score ===

$16224450605442 NAND SCORE:


=== misc/hdd_edit_button ===

$38481453712356 メモリの編集


=== levels/Switch ===

$19935950225431
Create a component that switches an input byte on or off.
If you get stuck, try [color=#e63e5b][url=byte_switch]this hint[/url][/color].
$77731476872422 Your answer {your_answer}\nCorrect answer {correct_answer}


=== levels/Further Delayed Lines ===

$17366913897135 Construct a circuit that outputs the same as the input, just delayed by 2 ticks.
$17497477227061
In the last level you unlocked the Delay Line. It outputs its own input, just 1 tick late.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356
We need a way to have negative values in bytes. The scheme we have been using so far can represent all numbers from 0 to 255 using a byte. This scheme is called "unsigned", since it only deals with positive numbers.

We need a scheme that allows negative numbers, normally referred to as a "signed" representation. 

Additionally, it would greatly simplify future circuits if the representation works with the adder you already made. 
$17231048881956 To know the difference between things, you need subtraction. To get subtraction, first you need negative numbers.
$70755151984986 {a} should be {b}
$11067230116844 {number} is not representable
$62744038163781 OK
$19118970740682
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).
$15431436023571 You have two ways to represent 0\nWhich leads to 0 + 1 = 0
$28284583096369 1 plus -1 does not equal 0\n  
$57604042654667 {number} is not representable


=== levels/Masking Time ===

$19351773688761 Ticks left: {ticks_left}  Input: {input}
$16810715868480 Calculate modulo 4 of the input.
$17375862136921
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.
$65431688078892
In this level you are given a number as input and you should return that number modulo 4 as a result.

The challenge is that you only have {ticks_per_test} ticks to output the desired result.

Note, you don't need to change your hardware, you just have to figure out the trick to do modulo 4 quickly.
Use [color=#e63e5b][url=masking_time]this hint[/url][/color] if you get stuck.
$81055582534899 Anyway new year is coming up and we want you to calculate the weekday of everyone's birthday. We will give you the date and all you have to do is return the weekday within {ticks_per_test} ticks.


=== levels/robot_race ===

$15403032472607 Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959 This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== levels/NAND Gate ===

$17420270098223 In this level the challenge is to figure out how the NAND component works. Be [color=#dd6576]sure[/color] to figure it out before you complete this level, or you will get stuck next level!
$11034378482152 Correct! You have unlocked the NAND gate. With this component you can build everything else in your computer!
$18270083417453 Check
$19208664264770 [b]Instruction[/b]\nClick any of the gray buttons in the last row of the table.
$17923274216766 We have decided you are probably not a plant.
$14777350869870 We are very impressed with how well you completed the last test!
$17994568832660 [b]Instruction[/b]\nThe NAND component in the middle changes the flow of the circuit.\nUse the bar on the left to experiment with the inputs, see how they affect the output and fill in the last row of the table.


=== components/Input 2 ===

$86870364449392 入力


=== main_scripts/overture_level ===

$27259865408750 Next tick the counter value will be {next}, it should be {expected}
$95030012922256 Input should only be enabled when reading from input
$12873109232054 Expected output {expected}, got {got}
$47188699762650 Output not enabled
$28026304798371 Output should only be enabled when outputting
$85260864781281 Input not enabled
$96569633331621 Load {value} into REG 0
$83829200305236 Expected output {expected}, got {got}


=== levels/byte_adder ===

$16888130664370
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173 Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== misc/ide_control_link ===

$80788685813993 ロボット制御


=== levels/saving_gracefully ===

$14295883660596 VALUE
$14950983012226 SAVE
$14837033157870 ACTION
$12474728041023
Delay Lineでは、1ティック分の値しか保存できません。しかし,より長い時間値を保存できるコンポーネントが便利な場合もあります.

私たちはそんなコンポーネントを作ってほしいのです.
$13045361823397 DON'T SAVE
$13740696609075
このレベルでは,2つの入力があります.
最初の入力が [ON] のとき,保存されている値を更新します.
2番目の入力は値です.

[img]dialogue/saving_gracefully/bit_memory.png[/img]
現在保存されているものを常に出力する.


=== levels/Calibrating Laser Cannons ===

$11331851878040 また,アセンブリプログラミングを利用できるようになりました.命令名を追加することができるので,68を入力する代わりに "add" と入力することができます.
$11023157447564
2×π×r

r は入力です.
π は 3 として近似するものとします.

計算が完了したら,答えを出力してください.
$15260627694444 そのレーザーを校正するために,高度な計算式で小惑星の円周を計算してほしいのです.
$12669851602178 [center]小惑星の外周を計算する[/center]
$21601709632806 2π × {radius} とは?
$16954408093587 私たちの船では,迫ってくる小惑星を当然レーザーで撃ちます.


=== levels/circular_dependency ===

$16336401898647 テスト 1/2
$13880985462901 あるコンポーネントの入力がそれ自身の出力に依存するような回路を作成する
$18010308863615
"circular dependency"を作成する. これは,あるコンポーネントの入力がそれ自身の出力に依存している回路です. 循環型依存関係の状況では,まず入力を決定する必要があり,それが出力に依存するというように,コンポーネントの出力を決定することはできません(それゆえ"循環型"なのです).

この状態は通常ほかのレベルでは許されませんが,このレベルではそれを作ることが目的なので,それがどういう状態かを理解した上で先に進みましょう.
$13520037133129 生徒のためになっているのかどうかはわかりませんが,先生方には好評です.
$11316928751185 私たちの教育システムでは,伝統的に生徒を騙して悪いことをさせ,そしてからかうという方法で教えています.


=== ui/top_bar/scores ===

$56840961921536 NAND SCORE: \nDELAY SCORE:


=== levels/Water World ===

$13739681561355 Total volume: 
$19185457941725 Good news, we want to turn earth into an exotic water park!
$18940654086036 We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652 Hit ENTER to show water
$12881972193444
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== misc/profile ===

$32835651830157 プロフィール


=== levels/Dancing Machine ===

$14975070588197
私たちは皆,ロボットのダンスフロアでの動きが好きなんです.だから,私たちのダンスチームを率いてほしいのです.
	
ただ一つの問題は,彼にオリジナルのダンスを考えさせることです.決定論的なロジックからどうやって創造性を生み出すのかって？

答えは擬似乱数発生器です.
$15955150920362
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.

In the algorithm below, "shl 1" means shift left once, "shl 2" means shift left twice and "shr 1" means shift right once.

[b]8 bit xorshift RNG:[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Next output next_seed mod 4, to move the robot. Finally use next_seed (before mod 4) as the seed to get the next number in the dance sequence and repeat.

(初期シードは決して0にならないことに注意してください)


=== components/Input 4 ===

$11447837612693 入力


=== levels/Add 5 ===

$11540713506719
これでパソコンのプログラムを自由に変更することができます.
プログラムコンポーネントの編集アイコンをクリックすると,プログラミングが開始できます.
$19281970848639 [center]入力に5を加算する.[/center]
$17770257567603 だから,その間は少し船の手伝いをしてもらうことになります.
$19446152707984 プログラムコンポーネント上のメモリ編集アイコンをクリックし,コンピュータのプログラミングを開始します.あなたのコンピュータは入力を読み取り,それに5を加えて再び出力するはずです (オーバーフローの心配は不要です).
$80639633676917 入力:
$12078933051174 でも,まだプログラミングの仕方が分からないので,その辺はまだまだですね.
$11074247151096 Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542 あなたはコンピュータを作り上げましたが,競争に勝つためには,迷路を完成させなければなりません.


=== misc/program_edit_signals ===

$98772447663910 監視状態の編集


=== misc/credits ===

$15234594767991 クレジット


=== misc/specifications ===

$68054407020318 手順


=== misc/delete ===

$53448014080434 削除 (ホットキー: 右クリック)


=== misc/controls2 ===

$38773676077206 手順を編集


=== levels/1_decoder ===

$16057674753878 2つのピンの間で信号を切り替えることができるコンポーネントを作成する.


=== levels/byte_mux ===

$49305362057225 あなたの解答 {your_answer}\n正しい解答 {correct_answer} (入力 {input})
$18296416014178 ビットセレクタ入力が [OFF] の場合はバイトAを出力し,それ以外の場合はバイトBを出力します.
$17093993196554
テストには合格しなかったが,私たちはこの犬を飼うことにした.他の地球人とは違って,彼はふわふわしていて,簡単な指示にはよく従います.

お互いの欠点をうまく補い合っているので,二人を組ませるのもいいかもしれませんね.


=== components/Input1_1B ===

$10517158300617 入力


=== misc/factory_back ===

$98930461722118 レベルに戻る


=== misc/component_factory_toggle ===

$55499239951858 コンポーネントファクトリー


=== levels/unseen_fruit ===

$13023474026617
あなたの惑星で最も注目されているのは,果物です.それはとてもおいしい.

そこで,食堂でフルーツの試食会を開催しています.
$14259900563789 ベルトコンベアーに一定間隔で入ってくるフルーツをスキャンします.同じ種類の果物を2回見つけたら,すぐに回転して操作盤を押してください.
$17070232883226 しかし,同じ果物が2度出てくるのは恥ずかしいので,それは避けたいところです.


=== ui/toggles/negative_numbers ===

$51779464354363 符号付き数字への変換


=== misc/reset ===

$39440928972984 リセット (ホットキー: F4)


=== levels/conditions ===

$12951779797594
このレベルは,値入力と3つの条件ビット入力を持ちます.

3ビットで下図のような条件を選択します. 選択された条件と値を照合し,条件を満たす場合は [ON] を,満たさない場合は [OFF] を出力します.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
$16407231803964 If VALUE < 0 output [img]dialogue/on.png[/img]
$16742265812068 Regardless of VALUE output [img]dialogue/on.png[/img]
$17616699231679 If VALUE > 0 output [img]dialogue/on.png[/img]
$16632557438774 If VALUE ≠ 0 output [img]dialogue/on.png[/img]
$18234235689107 If VALUE ≥ 0 output [img]dialogue/on.png[/img]
$12429396872036 Regardless of VALUE output [img]dialogue/off.png[/img]
$19014698800906 If VALUE = 0 output [img]dialogue/on.png[/img]
$13680487623452 If VALUE ≤ 0 output [img]dialogue/on.png[/img]
$12706881725738 回路がコンポーネントファクトリーに保存されました.


=== levels/full_adder ===

$17063157033479
前回は2つの入力を足し算しましたが,今回は3つの入力を足し算します. もう一度,入力を2進数で加算して,結果が [ZERO] か [ONE] になるようにします.

通常の足し算と同様,結果が1桁で表現できない場合は,キャリーを [ONE] にセットします.


=== levels/or_gate ===

$12749704931323 私たちの輝かしいテストに参加できることを喜ぶべきでしょう.
$11472059692644 あなたは銀河系文明の超高度な人々とコミュニケーションする機会を得ることができます.


=== misc/factory_back_inner ===

$12211557416281 レベルに戻る


=== nim/backend ===

$0
.int64
    if id notin self.translation_entries: return text
    return self.translation_entries[id]

  proc get_translation(gd_id: int64): string {.gdExport.} =
    let id = (gd_id - 3133700000000000000).int64
    if id notin self.translation_entries: return 


=== levels/sandbox ===

$17054292175058 サンドボックスへようこそ、ここで自由にお遊びください. 64ビットワイヤといくつかのIOコンポーネントをお渡ししました.
$10731996208080 プログラム、カウンタ、レジスタ、RAMの64ビット版もあります. ただし,64ビットのRAMはロードに1ティックかかります.
$19454393978813 キーボードはコンピュータをあなたのキーボードを利用して,直接操作することができます.
$14434122873489 波形ジェネレーターで音を作ることができます.これをあげると,たぶん後悔しますよ.
$18405942066048 時計は,現在のUNIXの時刻をマイクロ秒単位で表示します.
$10451578314373 コンソール画面では,画面に文字を描画することができます (ascii文字についてはマニュアルをご覧ください)


=== levels/and_gate ===

$15232844525838
表と一致する回路を作成する.
	
[tip]コンポーネントをダブルクリックすると,接続されたワイヤと一緒に移動します.[/tip]
$15231724707514 がっかりさせるつもりはないのですが,象が競争に勝つと思うのです.悪気はないのですが,それに比べてあなたの脳は小さいですから.


=== ui/toggles/race_condition ===

$75558678297830 Circular dependency


=== levels/Crude Awakening ===

$12508086025944
あなたをテストしています.

ルールは簡単で,機能的なコンピュータを作らないと食べられてしまうのです.健闘を祈っています.
$16321577947087 おめでとうございます!あなたは誘拐されました!
$19257730429557
"IN" から "OUT" に信号が流れます.
左上の "入力" の下に,緑色のアイコンがあります,
これをクリックすると "IN" がオフになります. 
$17675121574388 OUTがオフになっていることに注意してください.\nこれは、INから信号が流れなくなったためです.


=== misc/circuit_color ===

$78287906849040 ワイヤーの色


=== misc/instr_clone ===

$69090690657232 クローン


=== levels/byte_or ===

$10368115829346 でも実際は,野生でいい暮らしをしていたから大丈夫だし,肉を無駄にすることもないんです.
$15923734370936
入力バイトの各ビットをOR演算して結果を出力する.

例:
[code]
入力 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
入力 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
出力  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]

$15226896485081 競争に勝てなかった地球人を全部食べるなんて,倫理的にどうかと思うかもしれませんね？


=== ui/toggles/level_log ===

$38557550573896 レベルログ


=== levels/Conditionals ===

$10794262854382
Add if statements to your circuit. For the if statements, the 2 引数s are compared and if the condition is true, the counter is set to a jump address.
	
The previous instructions had the 4 bytes represent:
[code][color=#87a8c8]オペコード, 引数_1, 引数_2, RESULT[/color][/code]

For if statements the bytes represent:
[code][color=#87a8c8]オペコード, 引数_1, 引数_2, JUMP_ADDRESS[/color][/code]

In addition to the previous オペコード, add:
[code][color=#87a8c8]32 IF_EQUAL
33 IF_NOT_EQUAL
34 IF_LESS
35 IF_LESS_OR_EQUAL
36 IF_GREATER
37 IF_GREATER_OR_EQUAL[/color][/code]

Use unsigned less / greater for the comparisons.

Each オペコード does what their name implies. 例 the following jumps to byte 16 if REG0 is less than REG1: 
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]

$18542005958715 Set the counter increment to 4
$17133561664335 Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$14973719570693 Add a counter to the circuit
$12920514303805 Add 6 registers to the map
$14309211963063 Create a new schematic and add a program with 4 byte output
$16826220977157
 [color=#b72d41][b]TIP:[/b][/color] 
 COPY is just ADD with the second
 引数 being 0
$14690660047411 Implement the condition オペコード
$30132649789584 Watched state {number} should point to the output
$18994998239232 I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what オペコードs to use and so on.
$12034111753799 Watched state {number} should point to the counter


=== misc/change_schematic ===

$79554853897000 スイッチの設計図


=== levels/byte_less ===

$11252365204151 1番目の入力が2番目の入力より小さいとき, [ON] を出力する回路を作成する. バイトは [color=#dd6576]符号無し[/color] であると解釈してください.
$62766453128684 {a} は {b} より小さいか?
$11632471752785 [center]最初の入力が2番目の入力より小さいかどうかを判断する.[/center]


=== levels/Logic Engine ===

$15865646260225
 [color=#b72d41][b]WISDOM:[/b][/color] 
 苦痛は一時的なもの,
 栄光は永遠に
$17594613477534
2つの入力をOR、NAND、NOR、ANDできるデバイスを作成します. 3つ目の入力は [INSTRUCTION] になります. [INSTRUCTION] とは、何を計算するかを決める番号のことを形式的にそう呼んでいるだけです.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

このレベルでは,赤のコンポーネントを移動することはできません.理由は後に明らかになります.


=== levels/always_on ===

$17712385236630 常時[ON]の回路を作成する.


=== levels/sr_latch ===

$18317133991943
 [color=#b72d41][b]TIP:[/b][/color] 
 このようなインラインSRラッチは,
 すべてのレベルで有効にすることができます.
 オプションメニューから選択可能.

$18165461234561 Delay lines are easy to understand and can be used to build any computer architecture. However, modern hardware no longer use these as a basis for memory.
$15754153332116
This level introduces the concept of latches. This mechanic is not used anywhere else in the game. However, this level is here for the sake of completeness.  
	
If you do not have experience with electronics, it is recommended that you skip this level. You can always come back later.
$15213907597666 Using 2 NOR gates, build the circuit that matches the table. You will need a latch.
$19448398663695
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the circuit, the wires either flicker between [ON] and [OFF], or settle in a stable state.
	
When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such circuits are called "latches".
$10290382368587
In this level (and only this level), components may depend on themselves or form loops of up to two components. Despite depending on their own output, some of these circuits have stable outputs, at least for some inputs.

The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.


=== misc/inst_new_rule ===

$41064305626707 新しいルール


=== levels/byte_xor ===

$19636386696963 2バイトをビット単位でXOR演算する回路を作成する.


=== misc/multi_select ===

$85147529532131 複数選択 (ホットキー: SHIFT & drag)


=== levels/binary_racer ===

$16076448195257 このレベルは、私の大好きな遊びです.時間的なプレッシャーの中で,10進数を2進数に変換してみましょう.
$37319690622142 よくやった, レベル {current_level} に到達したぞ.
$19111664765554
レベルパネルのビットを切り替えて,問題の10進数になるようにしてください.

合格するにはレベル3まで到達する必要があります。

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)
$11176073682097 2進数で {number} は?
$71866932309393 レベル {level} に到達!


=== levels/Immediate Values ===

$64348543296709 監視状態 {value} は出力を指す必要があります.
$14060810229477 マップに6つのレジスタを追加
$79667526283284 監視状態 {value} はカウンタを指す必要があります.
$13396354780304 引数 1
$14960344494328
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the オペコード. We can do that in the following way:
	
When the 8th bit of the オペコード is [ON], use 引数 1 as an immediate value, instead of as a register address.
When the 7th bit of the オペコード is [ON], use 引数 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		

$28668442247273 JUMP TO
$10788301006338 監視状態 {nr} は,レジスタまたはレジスタを内部に持つカスタムコンポーネントを指す必要があります
$31564629398121 オペコード
$14073567083496 引数 2
$19338533633006 カウンターのインクリメントを4に設定する
$15197362332657 新規に回路を作成し、4バイト出力のプログラムを追加する
$18004215603701 回路にカウンタを追加する
$98173834092208 RESULT ADDRESS
$10141611261952 [center]即値の実装[/center]


=== levels/xor_gate ===

$14093358515620 This is also known as an XOR gate. This level is difficult, so don't be discouraged if you don't get the answer right away.
$19182751521677 Last level you built a circuit that was [ON] when we were at the second tick. This level build a circuit that is [ON] when we are at the second OR third tick.


=== levels/xor ===

$11589029892097 入力ビット {a} と {b} をXOR演算する
$12758156517177 コンピュータの命令を利用し,入力を2回読み取って,2つの値をXOR演算する
$16047615798435 [center]入力を2回読み取り,2つの入力のビットをXOR演算する[/center]


=== misc/menu ===

$56916384895438 メインメニュー


=== levels/Wire Spaghetti ===

$17106892574116 回路にカウンタを追加する
$20104629254326 引数 2
$15754373587500 カウンタのインクリメントを4に設定
$56024330661504 Watched state {watched_state} should point to a register or custom component with a register inside
$19099471819164
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit watched state" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.

$18860645759682
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]オペコード[/color]).

Since many operations take 2 引数s (like ADD, OR etc), the second and third byte are for 引数s.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$11377431500625 マップに6つのレジスタを追加
$14051336765362 Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$38681417496680 引数 1
$13268807052125 (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$30006055126224 Watched state {output} should point to the output
$19066122929275 [center]Set up registers and implement the ADD オペコード[/center]
$60997201855346 RESULT ADDRESS
$10912834168905
Finally, in this level the [color=#e49f44]オペコード[/color] is always 0. This means we ADD 引数 1 and 引数 2 and save the result to the destination.

The value of an 引数 or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: レジスタ 0
[color=#e49f44]1[/color]: レジスタ 1
[color=#e49f44]2[/color]: レジスタ 2
[color=#e49f44]3[/color]: レジスタ 3
[color=#e49f44]4[/color]: レジスタ 4
[color=#e49f44]5[/color]: レジスタ 5
[color=#e49f44]6[/color]: カウンタ
[color=#e49f44]7[/color]: 入力/出力
[/code]

In the next level you will implement more [color=#e49f44]オペコード[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].


$10922418807673 引数7は入力からの読み込みを意味しますが,入力は有効ではありません.
$62258842382434 監視状態 {counter} はカウンタを指す必要があります.
$84307766381146 オペコード
$20950946171790 JUMP TO
$18769284297247 新規に回路を作成し,4バイト出力のプログラムを追加する


=== levels/bit_adder ===

$13109388951000 We measure the universe with numbers. So your machine must learn to count.
$16564356062672
Treat the inputs as [ZERO] or [ONE] depending if they are [OFF] or [ON]. Add them together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== components/Output 3 ===

$96269858195218 出力


=== components/Output 1B ===

$77044600156969 出力


=== components/InputConditions ===

$75386511637758 入力


=== levels/and_gate_3 ===

$14788981567936 3入力のANDゲートを作成する.


=== levels/double_number ===

$74261206899285 Your result {input} × 2 = {your_answer}\nCorrect result {input} × 2 = {correct_answer}
$19766257822639
The input and output of this level are using bytes instead of bits. One of the two new components you are given takes a byte and splits it into bits and the other does the opposite.

Using those components, figure out how to double the input number (up to 127).


=== levels/counting_signals ===

$10724914203078
このレベルの出力コンポーネントは,最初の3ピンが1,2,4に対応するバイナリカウンタです.
バイナリカウンタを使用して,信号の数を数えます.

困ったときは, [color=#e63e5b][url=counting_signals]このヒント[/url][/color] をご覧ください

[i][tip]このレベルの回答は,あまりスッキリせず,多くのコンポーネントを必要とします.[/tip][/i]

$10881918807029
 [color=#b72d41][b]TIP:[/b][/color] 
 紙とペンを使うことを
 恥じる必要はありません.


