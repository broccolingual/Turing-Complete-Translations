=== levels/Spacial Invasion ===

$19967210826470 Be aware that the laser can only shoot when there are no other laser beams already in flight.
$16294185981398 The cargo hull has become infested with space rats.
$11505369795084 Check [color=#e49f44][url=the_robot]robot page[/url][/color] for instructions on how to program him. There is a link to that page in the program editor as well.
$10515630949378 We have hooked your machine up to our advanced robot and we want you to program it to shoot the space rats with lasers.


=== components/OutputQword ===

$43552728118031 Output


=== components/Output 1 ===

$12242923444593 Output


=== levels/RAM ===

$17967666262990 In this test, first copy from input 32 times and store these values. After you have loaded the 32 values, output them in the same order as you got them. Outputting before you have read all the inputs will fail the level.
$13520918982355 Add a ram block, so the computer can address 256 additional bytes of memory. You need a way to decide which of the 256 bytes inside the ram we are addressing. Select a register and wire it up, so its value always selects the RAM address. When you later want to load or save to the RAM, you will have to first copy the RAM address to this register.


=== levels/byte_less_i ===

$16755383054285 [center]Determine if the first input is less than the second.[/center]
$19006843777401 Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]SIGNED[/color].
$46083799633716 Is {input_1} less than {input_2}?


=== ui/toggles/level_map ===

$71951682957395 Level map


=== ui/state_ui/title_screen/exit ===

$12639868461113 exit


=== misc/button_next ===

$50213503063080 Next tick (Hotkey: F5)


=== levels/saving_bytes ===

$10633476398156
Create a circuit that can [SAVE] or [LOAD] a byte.

When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.

$15510981129613 LOAD
$13502950630653
[color=#ff9800]None
0
0[/color]
$19109563882664 DON'T LOAD
$16372198430230 SAVE
$11467279617581 SAVE
$15498440508450 Do nothing
$10080722944246 DON'T SAVE
$18873598212433 LOAD
$15582618410991 LOAD and SAVE


=== levels/maze ===

$13225915898937
If you choose to go on to the rest of the levels I will teach you about ram, the stack and function calls and you will get to solve more interesting challenges like this one.
		
But first you would have to build a better computer. [color=#e49f44]OVERTURE[/color] was good as a first machine, but it is clumsy and programs get very messy. To solve the challenges I have for you without pulling all your hair out, you will need something more expressive, the [color=#e49f44]LEG[/color] architecture.
$17275059688693 Congratulations, you won the competition! An amazing achievement!
$13741358519166 The fabled maze. If you solve it you win the competition!
$11103446544344 On the other hand, you could also retire, be proud and enjoy your reward of not being eaten.
$19331074553774
Write an algorithm that gets the robot from the start to the exit. 

This level is hard, you probably want to write down the pseudocode for your algorithm before you implement it.

Use [color=#e63e5b][url=maze]this hint[/url][/color] if you get stuck.

[tip]Remember you can't use immedate values larger than 63, a common mistake is to try to jump to a label further down than the 63rd byte.[/tip]


=== misc/level_gate_component_icon ===

$83440578602427 Unlocks component


=== levels/any_doubles ===

$16587030847545 Because we are so technologically advanced we have machines fold our socks. Unfortunately the circuit that detects sock pairs broke on the machine.
$14373083988184
This level has 4 inputs. 
Output [ON] when 2 or more of them are [ON].

[tip]Don't overthink this level.[/tip]


=== levels/byte_constant ===

$12641789008694 Create a circuit that always outputs the number 164.


=== components/Output 1 + 1B ===

$81929942356043 Output


=== levels/call_ret ===

$15840165316981
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.

$19416009887091
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=termonology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$19369640789869 Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.
$15463931654475 [center]Add "call" and "ret" instructions[/center]


=== levels/push_pop2 ===

$10062117579269 Add the stack to your computer
$14685569269160
In this level you are supposed to add the stack to your computer and write the program that solves the level.
When the input is 0, you should [color=#e49f44]pop[/color] a value off the stack and output it. When the input is not 0, you should [color=#e49f44]push[/color] it on the stack.
$18561605111721 PUSH {input} on stack
$59658696292688 POP {value} off stack


=== levels/odd_ticks ===

$18510295620397 Output [OFF] on the even ticks and [ON] on the odd ticks.
$16987046679863 In a previous level you learned how we don't allow circular dependencies. Now you must learn the one exception.
$16037516781370
Square pins in the game never affect the output in the same tick. They therefore never cause circular dependencies.
	
	[img]dialogue/delay_buffer.png[/img]
$17588119878416
The delay line is allowed to depend on its own input. This is because its input does not influence the rest of the circuit until next tick.
	
[img]dialogue/delay_buffer.png[/img]


=== main_scripts/leg_level ===

$70383685548547 REG {nr}
$53021804895845 ANDi
$69956969985790 ORi
$85913831661289 IF_LESS
$11144256835662 XORi
$61412773713567 SUB
$52344899983501 IF_LESS_OR_EQUAL
$89945092889418 SUBi
$89011349770597 NOT
$71559031724238 IF_NOT_EQUAL
$40520283279584 XOR
$71204580217527 NOTi
$71195301111400 ADDi
$98178474649432 IF_GREATER_OR_EQUAL
$68187490877029 IF_EQUAL
$50722296752142 INPUT
$43723329256095 REG {nr}
$37810243909140 COUNTER
$44009845985661 ADD
$68666991962246 OR
$79492115258673 IF_GREATER
$64519909700148 AND
$49810487048038 COUNTER
$18236360532765 OUTPUT


=== ui/options/Robot Controls ===

$58799802152286 Robot Controls


=== misc/solution_option ===

$21618236951146 View solution


=== misc/run_fast ===

$49363678936533 Run ticks faster (right click: change target speed)


=== misc/delay_overlay ===

$85430022417382 Show delay


=== misc/options ===

$49251062339706 options


=== levels/turing_complete ===

$15326252036920 Before, only code could influence memory, now memory must influence code. With the addition of conditional logic, our computer can run any algorithm, and calculate anything calculable.
$16583885726240 Yes you did it! I thought you were just this odd looking hairless ape creature, but you actually built a real computer! Amazing.
$10510746154639 At tick 1 the program should load address 1.
$10317244906317 No program found
$14587485007736 Until this point all possible programs have been confined to running in order byte by byte.
$19649119273248
The final thing we need to add is a mechanism for changing the program counter through [INSTRUCTIONS] when certain conditions are met.

When the two largest bits are [ON][ON], we are in condition mode. In condition mode, the value in REG 3 is compared against the conditions defined by the lowest 3 bits in the instruction. If the condition is true, we overwrite the counter to the value in REG 0.
Conditionally changing the counter means we can skip [INSTRUCTIONS] based on conditions or have [INSTRUCTIONS] run in a loop.

Conditions:
[OFF] [OFF] [OFF] Never
[OFF] [OFF] [ON] If [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] If [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] If [color=#e49f44]REG 3[/color] ≤ 0 
[ON] [OFF] [OFF] Always
[ON] [OFF] [ON] If [color=#e49f44]REG 3[/color] ≠ 0 
[ON] [ON] [OFF] If [color=#e49f44]REG 3[/color] ≥ 0
[ON] [ON] [ON] If [color=#e49f44]REG 3[/color] > 0

These conditions correspond to the condition component that was saved in the component factory.


=== components/Input 1 ===

$12746117288689 Input


=== levels/Second Tick ===

$14355963067874 Output [ON] on the second tick only.
$17526582195506 As you know these tests culminate in building a functioning computer.
$15726318553190 This is the main reason we don't eat you afterwards.
$19277843280528
 [color=#b72d41][b]TIP:[/b][/color] 
 You can select a component with 
 its pins by double clicking it
$15296208528991 Species that are capable of finishing are considered sentient by law.


=== levels/divide ===

$16412715945615 [center]Divide the two numbers[/center]
$14525870461271
Integer divide two numbers to find the quotient and the remainder. Consider the fraction 7/3. 3 goes into 7 2 times and 1 is left over. Here 2 is called the [color=#e49f44]quotient[/color] and 1 is called the [color=#e49f44]remainder[/color].
In this exercise, you are first given the numerator (7 in the example) and then the denominator (3) and you are then expected to output the quotient (2) and then the remainder (1).
$76454016047920 {numerator}/{denominator} = {quotient}, remainder {remainder}


=== levels/buffer ===

$10260210687588 [center]Test 2: Left input is [img]dialogue/on.png[/img], right output should be [img]dialogue/on.png[/img].[/center]
$13309706297402 [center]Test 3: Right input is [img]dialogue/on.png[/img], left output should be [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Make sure [img]dialogue/on.png[/img] can only flow from left to right.[/center]
$18349621873762 [center]Test 1: Both inputs are [img]dialogue/off.png[/img], neither side should turn [img]dialogue/on.png[/img].[/center]
$15504762262759
This level starts with 2 special components. They simultaneously act as input and output.

Make sure the signal flows only from left to right. There are 3 tests.

[b]Test 1[/b]: Both sides will be [OFF].

[b]Test 2[/b]: The left side input will turn [ON] and the right side should be [ON].

[b]Test 3[/b]: The right side output will turn [ON] and the left side should be [OFF].


=== components/Output 4 ===

$90190739202646 Output


=== misc/select_color ===

$97461374731210 Wire color


=== levels/component_factory ===

$17077079648771 Components can be added, renamed or deleted using the level save system.
$19551383617326
Welcome to the component factory, the circuits you create in here will be usable as components in architecture levels.
The circuitry you create defines the behavior of the component and the layout defines its shape.
$12516102012088 This component has no area and will not be usable in levels. Place components on the map to give it area.
$14712417427860 Since this level is a tool and not a challenge, you can go to the level map and continue on when you want.
$15549447390000 2 input/output components are in the same square. The custom component will be unusable since 2 pins can't overlap.


=== ui/state_ui/state_ui_output_bit ===

$40754755480566 Output


=== misc/instr_delete ===

$91861509153454 Delete


=== misc/instruction_expand ===

$44690074039467 Toggle define rules


=== levels/Delicious Order ===

$10160261151833 First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666 We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== levels/ai_showdown ===

$14940806461794
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678 NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012 This time he has taken over the control room and holds the captain hostage.


=== misc/ui_comment ===

$69987793052607 Wire comment (Click on wire)


=== levels/delay_level ===

$19986989895202
All components have a delay. And in a circuit, the total delay is determined by the slowest path. This means you normally want to put things in parallel.
In this level you must prove that you understand this concept.
$11246430085016 Note, you can see the delay path by clicking the hour glass in the upper right corner.
$12817338693402 The delay of any component is ultimately derived from the delay of the nand gate, which has a delay of 2. Build a circuit with a delay of 6 and a nand cost of 5.


=== levels/push_pop ===

$78804623186243 OUTPUT
$49526452710191 DON'T POP
$58050047963238 VALUE
$30926395960020 PUSH
$19245209470436 Create a stack
$12227209887733 Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
$85171087236638 ENABLE
$15662660252584 Do nothing
$23726790986805 POP
$62469306234943 DON'T PUSH
$46948857059388 POP value {value} off stack
$18761197388580 In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.
$65188797398656 PUSH {value} on stack


=== levels/Tower of Radioactive Alloy ===

$13757925963562 Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686 We need you to help clean up the basement.
$35120623183961 Move from {source} to {destination}
$15855497886737
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== levels/The Product of Nibbles ===

$14622683750375 Bit 2
$14957949958941 What you did here was actually multiplying two 4 bit numbers. We had the intern scale it up to bytes instead.
$17331397914567 Bit 1
$19136817138607 [center]Multiply the 4 bit numbers[/center]
$13232094477834 Bit 3
$13549246864135 Bit 0
$15857218442751 Bit 1
$18132100348781
 [color=#b72d41][b]TIP:[/b][/color] 
 Create nested components in the
 factory by changing the "nesting 
 level" in the file menu.
$14533861483435 Multiplying two 4 bit numbers gives you a 8 bit number. Build a circuit that does this.
$10430040077737 Bit 3
$10274387271390 Bit 0
$16301538038805 Bit 2
$83694551809785 Multiply {num1} and {num2}


=== components/Input 1 Byte ===

$40943344093513 Input


=== levels/signed_negator ===

$10866019808027 For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click "+255" located in the top panel.
$10400106910274
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
For example 4 negated would become -4. -9 negated would become 9.


=== levels/byte_and ===

$15885763626223 Create a circuit that ANDs two bytes bitwise.


=== ui/toggles/level_log2 ===

$91515053618360 Manual


=== main_scripts/functions ===

$11467644007149 Counter {nr}
$10533010562232 DELAY SCORE: {delay}
$87591753278764 Reg {nr}
$29169064199243 Output {nr}
$13327741293223 Input {nr}
$32508339206292 NAND SCORE: {nand}


=== levels/odd_number_of_signals ===

$16173829560311 Using a maximum of 3 components, output [ON] only when an odd number of inputs are [ON].
$85589489148198 Components spent\n{nr} of 3
$18288998816979 This level has a [color=#e63e5b][url=odd_number]hint[/url][/color] you can use if you get stuck.


=== levels/or_gate_3 ===

$15448906128695 Create an OR gate with 3 inputs.


=== ui/state_ui/title_screen/play ===

$82533529573294 play


=== nim/backend_lib/level_list ===

$58391129129347 Registers
$45936227746026 Counter
$12946639957230 NOT Gate
$16881141174140 Binary Racer
$37136208388559 SR Latch
$32191988336459 Saving Gracefully
$59136962133320 Logic Engine
$30920780473397 Circular Dependency
$83321010943153 Counting Signals
$58769021955965 3 bit decoder
$78673715398197 Immediate Values
$49679174636208 Byte XOR
$40356575891647 Byte OR
$44393538021725 Calibrating Laser Cannons
$87426564872318 Divide
$61228036919534 Tower of Radioactive Alloy
$24593959732668 Signed negator
$19487493622742 Half Adder
$26705128002562 Conditions
$94163943335575 The Sandbox
$64662599400870 Bit Inverter
$27566801288091 Component Factory
$14193654974055 Signed Less
$14522992467987 OR Gate
$74096060570427 Wide Instructions
$30630492494839 Byte NOT
$11457737665157 Wire Spaghetti
$59485174474959 Delicious Order
$85514901357243 Adding Bytes
$98013649264532 Stack
$35790581910835 Second Tick
$94979277765051 Robot Racing
$13303326918621 NAND Gate
$16463062897451 Crude Awakening
$77495536880911 NOR Gate
$61466151084505 Spacial Invasion
$20858506932774 AND Gate
$28827008935802 The Lab
$92696642439976 AI Showdown
$62326481348276 The Maze
$74512388889988 Arithmetic Engine
$50884376329157 Little Box
$70651296323768 XOR Gate
$31140969090253 Planet Names
$42873691377272 Add 5
$36114120875026 Storage cracker
$45773199639367 Odd ticks
$17198602105978 Unsigned Less
$43018398941741 Always On
$68155633878444 Delay
$15420972347773 RAM
$40549516333234 Byte AND
$33343343932901 Turing Complete
$95989050249094 Bigger AND Gate
$69830943995038 One Way
$63331549672739 Opcodes
$87626070552799 Full Adder
$13219675195117 ODD Number of Signals
$62167495140389 Shift
$28985439820134 The Product of Nibbles
$94896856420525 XNOR Gate
$25805639594354 Program
$57870391153000 Immediate Values
$56272944092958 Further Delayed Lines
$96825664933181 Unseen Fruit
$86717899742637 Saving Bytes
$53092952738479 Input Selector
$70993791338383 XOR
$77453667419150 Instruction Decoder
$17750429607702 1 bit decoder
$79570913613529 Double the Number
$59939822079116 Negative Numbers
$96898830278153 Byte Constant
$50992859018018 Switch
$49328023903824 Equality
$74292408260828 Calculations
$45480765206717 Conditionals
$71126291573555 Double Trouble
$33132016601448 PUSH and POP
$75225719777307 Water World
$64615090872051 Functions
$84208736840052 Masking Time
$91954159574064 Bigger OR Gate
$36221227239949 Dancing Machine


=== ui/options/Controls ===

$53266310714298 Control


=== levels/3_decoder ===

$19231618567710 With 3 bits of input there are 8 combinations. Make a circuit that selects 1 output for each of the 8 combinations. No more or less than 1 bit should be [ON] at a time.
$14293122338496 We had our intern add a "disable" bit to this component. We were tired of looking at him running in circles and were looking for other pointless and tedious tasks to give him.


=== levels/test_lab ===

$11038144815919
This level uses programs to test your circuits. When the programs are run, this level checks if the "watched state" behaves the way you expect.

The lab has 2 extra keywords.

The [color=#c54d5e]expect[/color] keyword is used to describe what a value a memory address should hold next tick.

The first number after [color=#c54d5e]expect[/color] is index in the watched state, the second number is the expected value. The watched state indexes are the order the components are connected up in to the program component.

[img]dialogue/watched_state.png[/img]

For example:
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

Here, the first line says that we expect the 2nd watched state slot to hold a value of 4 after the next tick.

All watched state is checked against expectations at every tick. All watched state is expected to be 0 at the start of the program, and expectations for memory components only change as you specifically change the expectations. The one exception are counters, these are naturally expected to increment each tick.

The second special keyword for the lab is [color=#c54d5e]set_input[/color]. With this you can control the input of the computer:
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

You can at any time also (re)import example tests by clicking below:
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]

$15446846177093 Welcome to the lab. Like the component factory, this is not a normal level but a tool.
$16072814175447 Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about circuits, when you are in the middle of solving a programming problem. It is tempting to apply a quick circuit fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!


=== levels/Opcodes ===

$19693461238792 Set the counter increment to 4
$38976231780455 Watched state {nr} should point to a register or custom component with a register inside
$20916717363300 Watched state {nr} should point to the output
$18189600217529 Implement the OPCODE instructions
$13450117997204 Add a counter to the circuit
$77044880242883 Watched state {nr} should point to the counter
$13870568875751 Create a new schematic and add a program with 4 byte output
$10303603301757
Implement the following opcodes:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The opcode NOT ignores the second argument.
$17495651785164 Add 6 registers to the map


=== levels/Nor GATE ===

$11362258372706
Most creatures on Earth are agressive and do not know how to focus.

To succeed you must learn to think logically, while not destroying things.


=== misc/run ===

$67345621265845 Run ticks (Hotkey: F6)


=== levels/byte_not ===

$14196498898485 Tool making and usage is key in the early evolutionary stages of developing intelligence.
$12982025748137 "NOT" each bit of the byte input.
$10294533225655 Our previous model of brain size being the main predictor of intelligence was naive.
$14958585065722 Therefore the number of arms on a creature is clearly the main predictor of intelligence. Did you know there are sea creatures from your planet with four times as many arms as you and they are doing better in tests?


=== levels/Storage cracker ===

$11910674853271
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673 You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== levels/constants ===

$17098439090371
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== misc/circuit_draw ===

$59836059268386 New circuit (Hotkey: Alt & drag)


=== misc/watchable_state ===

$58678516111149 Edit watched state


=== levels/program ===

$16693098943939
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479 The program is still outputting the first instruction. Did you hook up a counter?


=== levels/wide_instrucitons ===

$13709034294291 Save on even tick, output both bytes on odd ticks
$17693995237077 Output both bytes
$19068760748550 Output 0 on even ticks
$65009239162932 The correct outputs were {a} and {b}
$19203973423116 Create a device that saves the program output on even ticks, and outputs both bytes on odd ticks.
$17409169138995 Save the byte


=== components/Input 3 ===

$70689623552857 Input


=== levels/Arithmetic Engine ===

$16434409050195
Add addition and subtraction to your circuit.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810 We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837 Input: 
$11201813578269 Output: 


=== levels/byte_equal ===

$17156565273196 Output [ON] when both inputs are the same.


=== levels/Calculations ===

$14458828731919
Time to merge in the "Arithmetic Engine" circuit you made previously with the register circuit. The calculation circuit was saved in the component factory and can now be added as a component. If you forgot which pin does what, check the circuit in the component factory.

Use the decoder you built to figure out if we should copy between registers or do calculations. Here are the 4 different modes again:
[OFF][OFF] Immediate
[ON][OFF] Copy
[OFF][ON] Calculate
[ON][ON] Condition

For this level you only have to worry about the copy and calculate mode, check [INSTRUCTIONS] in the top panel for the details. When in calculate mode, take [color=#e49f44]REG 1[/color] and [color=#e49f44]REG 2[/color] as inputs, and save the result in [color=#e49f44]REG 3[/color].

[tip]Don't forget the 3 bit decoder component has a disable bit.[/tip]
$13013863429580 For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== levels/Counter ===

$17701404772563 Add 1
$17940006660359 Count
$17263901743088
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$68874699768861 Overwrite with {value}
$17883663978196 Overwrite
$19407121413983 ACTION
$10555159894041
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== components/InputQword ===

$31709565019284 Input


=== ui/options/General ===

$36195388998735 General


=== levels/not_gate ===

$19085882338208 [b]Instruction[/b]\nRight click to deselect
$10042327259531 Now that you unlocked the NAND gate, it is time for you to build a circuit.
$14042842216181 Last level you made the table that described the circuit. In this level you build the circuit that matches table.
$10604720087324 [b]Instruction[/b]\nBuild a circuit that makes the table correct.\nClick [i][/i] (Next tick) in the upper left corner to test each combination of inputs.\nYou win the level once both combinations have been tested correct.
$19798729463813
Using NAND gates, build the NOT gate

Using: [b]NAND gate[/b]
[code]INPUT 1: [OFF][ON][OFF][ON]
INPUT 2: [OFF][OFF][ON][ON]
OUTPUT:  [ON][ON][ON][OFF][/code]

Build: [b]NOT gate[/b]
[code]INPUT 1: [ON][OFF]
OUTPUT:  [OFF][ON][/code]

$18442122157391 [b]Instruction[/b]\nDeselect the component by clicking the background
$12880883686501 [b]Instruction[/b]\nClick on the NAND component on the top right side of the screen and place it
$18780831606716 [b]Instruction[/b]\nClick and drag on the board to add a wire


=== levels/byte_shift ===

$16023356915123
The task in this level is to shift the first input to the left by the value given in the second input. The second input will never exceed 7.

$37338672894296 Shift the bits of {value} left by {amount}
$10598344098990 [center]Shift the first input left by the number of places given by the second[/center]
$16216408139965
To [color=#e49f44]shift[/color] a value 1 left just means moving all the bits in a byte to the left by 1 position.
For example: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]


$18137790657923 In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.
$18518173140953 I recommend that you add [color=#e49f44]shift left[/color] and [color=#e49f44]shift right[/color] to your hardware for future levels.


=== misc/factory ===

$53123649343022 Component Factory


=== levels/registers ===

$10661964231175 I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$15888345020710
In this level you need to create a circuit which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color]. 

The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color]. 

Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$14823499195861 Open "Instructions" in the top bar
$14108238519744 Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593 Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755 Output


=== levels/xnor ===

$11090938799865 Create the inverse XOR gate, known as XNOR.


=== levels/decoder ===

$16133643476631 The circuit you built in the "Registers" level can copy values between registers, while the "Arithmetic Engine" can do different operations on 2 inputs. But you need to be able to do both in the same circuit. To do this, build a "decoder", which will decide which mode our computer is in, based on the 2 bits we haven't used yet.
$18435544383511 CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383 COPY
$18945946395447
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$16785126425267 CALCULATION
$15440615199508 CONDITION
$12671132029272 Your circuit has been saved to the component factory.
$15105859227432 COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12068329066372 [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408 CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611 IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542 IMMEDIATE


=== levels/bit_inverter ===

$15769391111364 When "Invert" is [ON], output the opposite of "Value". Otherwise, just output "Value" as is.
$15272914096446 This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527 Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$16125025706490 Hmm, perhaps you have studied memory a little bit too well...
$13224963076378 We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/ram_block ===

$17142958857584 A OR B
$12901484249817 Can you fit 4 bytes of memory in this limited space?
$14218335256117
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$19282543476901 1
$13765566466116 DON'T SAVE
$15908016538045 VALUE
$16196915566111 0
$32676754026463 Save {value} and load
$30856781458049 Save {value}
$14259545926196 A
$12306130287676
In this level you have to build a circuit that 
can [SAVE] or [LOAD] from 4 different bytes of memory.

You are given 1 bit that determines if you are to [LOAD]. Another bit determines if you are to [SAVE] and it comes with a corresponding value.
Additionally, you have 2 address bits. 

With 2 bits, there are 4 combinations, one for each byte of memory in this level.
[i][tip]Join wires in the middle and use right angles or this will be a mess.[/tip][/i]
[i][tip]Spacebar rotates components.[/tip][/i]
$16217965518477 B
$10891070331034 B
$18084166025569 Nothing
$13082830776248 DON'T LOAD
$17473197268827 LOAD
$13555908976270 0 OR 1
$10311371309532 SAVE
$16925432534232 LOAD
$13644027370563 Load
$12933801309767 A
$12291627335021 SAVE


=== misc/score_sync ===

$76911045833478 score sync


=== misc/level_gate_manual_icon ===

$22002156022920 Unlocks manual entry


=== misc/level_gate_unlocks_unknown ===

$76731326010721 Unlocks something unknown


=== ui/top_bar/nand_score ===

$16224450605442 NAND SCORE:


=== misc/hdd_edit_button ===

$38481453712356 Edit memory


=== levels/Switch ===

$19935950225431
Create a component that switches an input byte on or off.
If you get stuck, try [color=#e63e5b][url=byte_switch]this hint[/url][/color].
$77731476872422 Your answer {your_answer}\nCorrect answer {correct_answer}


=== levels/Further Delayed Lines ===

$17366913897135 Construct a circuit that outputs the same as the input, just delayed by 2 ticks.
$17497477227061
In the last level you unlocked the Delay Line. It outputs its own input, just 1 tick late.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356
We need a way to have negative values in bytes. The scheme we have been using so far can represent all numbers from 0 to 255 using a byte. This scheme is called "unsigned", since it only deals with positive numbers.

We need a scheme that allows negative numbers, normally referred to as a "signed" representation. 

Additionally, it would greatly simplify future circuits if the representation works with the adder you already made. 
$17231048881956 To know the difference between things, you need subtraction. To get subtraction, first you need negative numbers.
$70755151984986 {a} should be {b}
$11067230116844 {number} is not representable
$62744038163781 OK
$19118970740682
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).
$15431436023571 You have two ways to represent 0\nWhich leads to 0 + 1 = 0
$28284583096369 1 plus -1 does not equal 0\n  
$57604042654667 {number} is not representable


=== levels/Masking Time ===

$19351773688761 Ticks left: {ticks_left}  Input: {input}
$16810715868480 Calculate modulo 4 of the input.
$17375862136921
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.
$65431688078892
In this level you are given a number as input and you should return that number modulo 4 as a result.

The challenge is that you only have {ticks_per_test} ticks to output the desired result.

Note, you don't need to change your hardware, you just have to figure out the trick to do modulo 4 quickly.
Use [color=#e63e5b][url=masking_time]this hint[/url][/color] if you get stuck.
$81055582534899 Anyway new year is coming up and we want you to calculate the weekday of everyone's birthday. We will give you the date and all you have to do is return the weekday within {ticks_per_test} ticks.


=== levels/robot_race ===

$15403032472607 Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959 This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== levels/NAND Gate ===

$17420270098223 In this level the challenge is to figure out how the NAND component works. Be [color=#dd6576]sure[/color] to figure it out before you complete this level, or you will get stuck next level!
$11034378482152 Correct! You have unlocked the NAND gate. With this component you can build everything else in your computer!
$18270083417453 Check
$19208664264770 [b]Instruction[/b]\nClick any of the gray buttons in the last row of the table.
$17923274216766 We have decided you are probably not a plant.
$14777350869870 We are very impressed with how well you completed the last test!
$17994568832660 [b]Instruction[/b]\nThe NAND component in the middle changes the flow of the circuit.\nUse the bar on the left to experiment with the inputs, see how they affect the output and fill in the last row of the table.


=== components/Input 2 ===

$86870364449392 Input


=== main_scripts/overture_level ===

$27259865408750 Next tick the counter value will be {next}, it should be {expected}
$95030012922256 Input should only be enabled when reading from input
$12873109232054 Expected output {expected}, got {got}
$47188699762650 Output not enabled
$28026304798371 Output should only be enabled when outputting
$85260864781281 Input not enabled
$96569633331621 Load {value} into REG 0
$83829200305236 Expected output {expected}, got {got}


=== levels/byte_adder ===

$16888130664370
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173 Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== misc/ide_control_link ===

$80788685813993 Robot controls


=== levels/saving_gracefully ===

$14295883660596 VALUE
$14950983012226 SAVE
$14837033157870 ACTION
$12474728041023
The Delay Line only allows us to save a value for 1 tick. But sometimes a component that can save a value for longer periods of time is useful.

We want you to build such a component.
$13045361823397 DON'T SAVE
$13740696609075
In this level you have 2 inputs.
When the first input is [ON], update the saved value.
The second input is the value.

[img]dialogue/saving_gracefully/bit_memory.png[/img]
Always output what is currently saved.


=== levels/Calibrating Laser Cannons ===

$11331851878040 Also you now have access to assembly programming. It allows you to add names for instructions, so you can for example type "add" instead of inputting 68.
$11023157447564
2×π×r

r is the input.
And you can approximate π as 3.

Send the answer to output when it has been calculated.
$15260627694444 In order to calibrate said laser, we want you to calculate the circumference of the asteroids using an advanced equation.
$12669851602178 [center]Calculate the circumference of the asteroids[/center]
$21601709632806 What is 2π × {radius}?
$16954408093587 On our ship we naturally shoot incoming asteroids with lasers.


=== levels/circular_dependency ===

$16336401898647 Test 1/2
$13880985462901 Make a circuit where the input of a component depends on its own output
$18010308863615
Create a "circular dependency". This is a circuit where the input of a component relies on its own output. In a circular dependency situation, it is not possible to determine the output of a component, because you would first need to determine the input, which relies on the output and so on (hence the "circular").

This state is normally not allowed in other levels, but in this level the goal is to create it, so you understand what it is before going forward.
$13520037133129 I am not sure it benefits the students, but teachers love it.
$11316928751185 In our education system we traditionally teach by tricking students into doing the wrong thing and then teasing them.


=== ui/top_bar/scores ===

$56840961921536 NAND SCORE: \nDELAY SCORE:


=== levels/Water World ===

$13739681561355 Total volume: 
$19185457941725 Good news, we want to turn earth into an exotic water park!
$18940654086036 We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652 Hit ENTER to show water
$12881972193444
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== misc/profile ===

$32835651830157 profile


=== levels/Dancing Machine ===

$14975070588197
We all like the way Robot moves on the dance floor. That's why we want him to lead our dance team. 
	
The only problem is to make him come up with original dance sequences. How do you make creativity out of deterministic logic you ask?

The answer pseudo random number generators.
$15955150920362
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.

In the algorithm below, "shl 1" means shift left once, "shl 2" means shift left twice and "shr 1" means shift right once.

[b]8 bit xorshift RNG:[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Next output next_seed mod 4, to move the robot. Finally use next_seed (before mod 4) as the seed to get the next number in the dance sequence and repeat.

(Notice the initial seed will never be 0)


=== components/Input 4 ===

$11447837612693 Input


=== levels/Add 5 ===

$11540713506719
You are now free to change the program of your computer.
Click the edit icon on the program component to start programming.
$19281970848639 [center]Add 5 to the input.[/center]
$17770257567603 So in the meantime we will have you help out on the ship a little.
$19446152707984 Click on the edit memory icon on the program component to start programming your computer. Your computer should read an input, add 5 to it and output it again (no need to worry about overflow).
$80639633676917 Input:
$12078933051174 But since you don't know how to program it yet, you are not quite ready for that.
$11074247151096 Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542 You have built your computer, but to win the competition you still have to finish the maze.


=== misc/program_edit_signals ===

$98772447663910 Edit watched state


=== misc/credits ===

$15234594767991 credits


=== misc/specifications ===

$68054407020318 Instructions


=== misc/delete ===

$53448014080434 Delete (Hotkey: Right click)


=== misc/controls2 ===

$38773676077206 Edit Instructions


=== levels/1_decoder ===

$16057674753878 Create a component that can switch a signal between 2 pins.


=== levels/byte_mux ===

$49305362057225 Your answer {your_answer}\nCorrect answer {correct_answer} (Input {input})
$18296416014178 When the bit selector input is [OFF], output Byte A, otherwise output Byte B.
$17093993196554
Even though he did not pass our tests we decided to keep the dog. Unlike most earthlings he is fluffy and follows simple instructions well. 

We might want to team you two up, since you compliment each other's shortcomings well.


=== components/Input1_1B ===

$10517158300617 Input


=== misc/factory_back ===

$98930461722118 Return to level


=== misc/component_factory_toggle ===

$55499239951858 Component Factory


=== levels/unseen_fruit ===

$13023474026617
The most noteworthy thing on your planet is the fruit. It is very tasty.

That's why we are having a fruit tasting event in the canteen.
$14259900563789 Scan the conveyor belt for the fruit incoming at regular intervals. As soon as you have see the same kind of fruit twice, turn and press the control panel.
$17070232883226 But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.


=== ui/toggles/negative_numbers ===

$51779464354363 Toggle signed numbers


=== misc/reset ===

$39440928972984 Reset (Hotkey: F4)


=== levels/conditions ===

$12951779797594
This level has a value input and 3 condition bit inputs.

The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
$16407231803964 If VALUE < 0 output [img]dialogue/on.png[/img]
$16742265812068 Regardless of VALUE output [img]dialogue/on.png[/img]
$17616699231679 If VALUE > 0 output [img]dialogue/on.png[/img]
$16632557438774 If VALUE ≠ 0 output [img]dialogue/on.png[/img]
$18234235689107 If VALUE ≥ 0 output [img]dialogue/on.png[/img]
$12429396872036 Regardless of VALUE output [img]dialogue/off.png[/img]
$19014698800906 If VALUE = 0 output [img]dialogue/on.png[/img]
$13680487623452 If VALUE ≤ 0 output [img]dialogue/on.png[/img]
$12706881725738 Your circuit has been saved to the component factory.


=== levels/full_adder ===

$17063157033479
In the previous level we added together 2 inputs, this time we add 3. Once again, add the inputs together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== levels/or_gate ===

$12749704931323 You should be happy you get to participate in our glorious tests.
$11472059692644 You get a chance to communicate with very advanced people from the galactic civilization.


=== misc/factory_back_inner ===

$12211557416281 Return to level


=== nim/backend ===

$0
.int64
    if id notin self.translation_entries: return text
    return self.translation_entries[id]

  proc get_translation(gd_id: int64): string {.gdExport.} =
    let id = (gd_id - 3133700000000000000).int64
    if id notin self.translation_entries: return 


=== levels/sandbox ===

$17054292175058 Welcome to the sandbox, here you are free to play around. I have given you 64 bit wires and a few IO components.
$10731996208080 There are also 64 bit versions of the program, the counter, the register and the ram. Notice though, the 64 bit ram takes 1 tick to load.
$19454393978813 The Keypad lets you directly control your computer, using your keyboard
$14434122873489 The Waveform Generator lets you make sounds. I will probably regret giving you this one.
$18405942066048 The Clock gives you the current UNIX time in microseconds.
$10451578314373 The Console Screen lets you draw characters to a screen (see manual for ascii characters)


=== levels/and_gate ===

$15232844525838
Create the circuit that matches the table.
	
[tip]Double click on a component to move it together with connected wires.[/tip]
$15231724707514 I don't want to discourage you, but I think the elephant will win the competition. No offense but your brain is tiny in comparison.


=== ui/toggles/race_condition ===

$75558678297830 Circular dependency


=== levels/Crude Awakening ===

$12508086025944
We are testing you.

The rules are simple, build a functional computer or you will be eaten. Good luck.
$16321577947087 Congratulations, you have been abducted!
$19257730429557
A signal flows from the "IN" component to the "OUT" component.
In the upper left corner under "input" there is a green icon, 
click on it to turn the "IN" component off. 
$17675121574388 Notice that the OUT component is turned off.\nThis is because the signal stopped flowing from the IN component.


=== misc/circuit_color ===

$78287906849040 Wire color


=== misc/instr_clone ===

$69090690657232 Clone


=== levels/byte_or ===

$10368115829346 But actually it is OK because you lived good lives in the wild and we don't let the meat go to waste.
$15923734370936
OR each bit of the input bytes and output the result.

For example:
[code]
INPUT 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
INPUT 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
OUTPUT  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]

$15226896485081 You may think it is unethical to eat all the earthlings that don’t win the competition?


=== ui/toggles/level_log ===

$38557550573896 Level log


=== levels/Conditionals ===

$10794262854382
Add if statements to your circuit. For the if statements, the 2 arguments are compared and if the condition is true, the counter is set to a jump address.
	
The previous instructions had the 4 bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, RESULT[/color][/code]

For if statements the bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, JUMP_ADDRESS[/color][/code]

In addition to the previous opcodes, add:
[code][color=#87a8c8]32 IF_EQUAL
33 IF_NOT_EQUAL
34 IF_LESS
35 IF_LESS_OR_EQUAL
36 IF_GREATER
37 IF_GREATER_OR_EQUAL[/color][/code]

Use unsigned less / greater for the comparisons.

Each opcode does what their name implies. For example the following jumps to byte 16 if REG0 is less than REG1: 
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]

$18542005958715 Set the counter increment to 4
$17133561664335 Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$14973719570693 Add a counter to the circuit
$12920514303805 Add 6 registers to the map
$14309211963063 Create a new schematic and add a program with 4 byte output
$16826220977157
 [color=#b72d41][b]TIP:[/b][/color] 
 COPY is just ADD with the second
 argument being 0
$14690660047411 Implement the condition opcodes
$30132649789584 Watched state {number} should point to the output
$18994998239232 I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what opcodes to use and so on.
$12034111753799 Watched state {number} should point to the counter


=== misc/change_schematic ===

$79554853897000 Switch schematic


=== levels/byte_less ===

$11252365204151 Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
$62766453128684 Is {a} less than {b}?
$11632471752785 [center]Determine if the first input is less than the second.[/center]


=== levels/Logic Engine ===

$15865646260225
 [color=#b72d41][b]WISDOM:[/b][/color] 
 Pain is temporary, glory is 
 forever.
$17594613477534
Create a device that can OR, NAND, NOR or AND two inputs. The third input will be the [INSTRUCTION]. An [INSTRUCTION] is just what we call the number that determines what to compute.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Also you can't move the red components in this level, for reasons that will be revealed later.


=== levels/always_on ===

$17712385236630 Create a circuit that is always [ON].


=== levels/sr_latch ===

$18317133991943
 [color=#b72d41][b]TIP:[/b][/color] 
 Inline SR latches like this one
 can be enabled for all levels
 through the options menu.

$18165461234561 Delay lines are easy to understand and can be used to build any computer architecture. However, modern hardware no longer use these as a basis for memory.
$15754153332116
This level introduces the concept of latches. This mechanic is not used anywhere else in the game. However, this level is here for the sake of completeness.  
	
If you do not have experience with electronics, it is recommended that you skip this level. You can always come back later.
$15213907597666 Using 2 NOR gates, build the circuit that matches the table. You will need a latch.
$19448398663695
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the circuit, the wires either flicker between [ON] and [OFF], or settle in a stable state.
	
When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such circuits are called "latches".
$10290382368587
In this level (and only this level), components may depend on themselves or form loops of up to two components. Despite depending on their own output, some of these circuits have stable outputs, at least for some inputs.

The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.


=== misc/inst_new_rule ===

$41064305626707 New rule


=== levels/byte_xor ===

$19636386696963 Create a circuit that XORs two bytes bitwise.


=== misc/multi_select ===

$85147529532131 Multi select (Hotkey: SHIFT & drag)


=== levels/binary_racer ===

$16076448195257 This level is my favorite pastime. Converting decimal into binary under time pressure.
$37319690622142 Good job, you reached level {current_level}.
$19111664765554
Toggle the bits in the level panel so they add up to the decimal number in the question.

You must reach level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)
$11176073682097 What is {number} in binary?
$71866932309393 You made it to level {level}!


=== levels/Immediate Values ===

$64348543296709 Watched state {value} should point to the output
$14060810229477 Add 6 registers to the map
$79667526283284 Watched state {value} should point to the counter
$13396354780304 ARGUMENT 1
$14960344494328
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the opcode. We can do that in the following way:
	
When the 8th bit of the opcode is [ON], use argument 1 as an immediate value, instead of as a register address.
When the 7th bit of the opcode is [ON], use argument 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		

$28668442247273 JUMP TO
$10788301006338 Watched state {nr} should point to a register or custom component with a register inside
$31564629398121 OPCODE
$14073567083496 ARGUMENT 2
$19338533633006 Set the counter increment to 4
$15197362332657 Create a new schematic and add a program with 4 byte output
$18004215603701 Add a counter to the circuit
$98173834092208 RESULT ADDRESS
$10141611261952 [center]Implement immediate values[/center]


=== levels/xor_gate ===

$14093358515620 This is also known as an XOR gate. This level is difficult, so don't be discouraged if you don't get the answer right away.
$19182751521677 Last level you built a circuit that was [ON] when we were at the second tick. This level build a circuit that is [ON] when we are at the second OR third tick.


=== levels/xor ===

$11589029892097 XOR the bits of the inputs {a} and {b}
$12758156517177 Using the instructions of your computer, read the input twice and XOR the two values together
$16047615798435 [center]Read the input twice and XOR the bits of the two inputs[/center]


=== misc/menu ===

$56916384895438 Main menu


=== levels/Wire Spaghetti ===

$17106892574116 Add a counter to the circuit
$20104629254326 ARGUMENT 2
$15754373587500 Set the counter increment to 4
$56024330661504 Watched state {watched_state} should point to a register or custom component with a register inside
$19099471819164
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit watched state" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.

$18860645759682
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]OPCODE[/color]).

Since many operations take 2 arguments (like ADD, OR etc), the second and third byte are for arguments.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$11377431500625 Add 6 registers to the map
$14051336765362 Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$38681417496680 ARGUMENT 1
$13268807052125 (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$30006055126224 Watched state {output} should point to the output
$19066122929275 [center]Set up registers and implement the ADD opcode[/center]
$60997201855346 RESULT ADDRESS
$10912834168905
Finally, in this level the [color=#e49f44]OPCODE[/color] is always 0. This means we ADD argument 1 and argument 2 and save the result to the destination.

The value of an argument or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: Register 0
[color=#e49f44]1[/color]: Register 1
[color=#e49f44]2[/color]: Register 2
[color=#e49f44]3[/color]: Register 3
[color=#e49f44]4[/color]: Register 4
[color=#e49f44]5[/color]: Register 5
[color=#e49f44]6[/color]: Counter
[color=#e49f44]7[/color]: Input/Output
[/code]

In the next level you will implement more [color=#e49f44]OPCODES[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].


$10922418807673 Argument 7 means read from input, but input is not enabled.
$62258842382434 Watched state {counter} should point to the counter
$84307766381146 OPCODE
$20950946171790 JUMP TO
$18769284297247 Create a new schematic and add a program with 4 byte output


=== levels/bit_adder ===

$13109388951000 We measure the universe with numbers. So your machine must learn to count.
$16564356062672
Treat the inputs as [ZERO] or [ONE] depending if they are [OFF] or [ON]. Add them together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== components/Output 3 ===

$96269858195218 Output


=== components/Output 1B ===

$77044600156969 Output


=== components/InputConditions ===

$75386511637758 Input


=== levels/and_gate_3 ===

$14788981567936 Create an AND gate with 3 inputs.


=== levels/double_number ===

$74261206899285 Your result {input} × 2 = {your_answer}\nCorrect result {input} × 2 = {correct_answer}
$19766257822639
The input and output of this level are using bytes instead of bits. One of the two new components you are given takes a byte and splits it into bits and the other does the opposite.

Using those components, figure out how to double the input number (up to 127).


=== levels/counting_signals ===

$10724914203078
The output component of this level is a binary counter where the first 3 pins correspond to 1, 2 and 4.
Use the binary counter to count the number of signals.

Check [color=#e63e5b][url=counting_signals]this hint[/url][/color] if you get stuck

[i][tip]The solution for this level is not very neat and requires more components.[/tip][/i]

$10881918807029
 [color=#b72d41][b]TIP:[/b][/color] 
 There is no shame in using
 pen and paper


