=== levels/nand_gate ===

$17420270098223 In this level the challenge is to figure out how the NAND component works. Be [color=#dd6576]sure[/color] to figure it out before you complete this level, or you will get stuck next level!
$11034378482152 Correct! You have unlocked the NAND gate. With this component you can build everything else in your computer!
$18270083417453 Check
$19208664264770 [b]Instruction[/b]\nClick any of the gray buttons in the last row of the table.
$17923274216766 We have decided you are probably not a plant.
$14777350869870 We are very impressed with how well you completed the last test!
$17994568832660 [b]Instruction[/b]\nThe NAND component in the middle changes the flow of the circuit.\nUse the bar on the left to experiment with the inputs, see how they affect the output and fill in the last row of the table.


=== levels/xnor ===

$11090938799865 Create the inverse XOR gate, known as XNOR.


=== levels/decoder ===

$16133643476631 The circuit you built in the "Registers" level can copy values between registers, while the "Arithmetic Engine" can do different operations on 2 inputs. But you need to be able to do both in the same circuit. To do this, build a "decoder", which will decide which mode our computer is in, based on the 2 bits we haven't used yet.
$18435544383511 CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383 COPY
$18945946395447
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$16785126425267 CALCULATION
$15440615199508 CONDITION
$12671132029272 Your circuit has been saved to the component factory.
$15105859227432 COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12068329066372 [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408 CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611 IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542 IMMEDIATE


=== levels/RAM ===

$17967666262990 In this test, first copy from input 32 times and store these values. After you have loaded the 32 values, output them in the same order as you got them. Outputting before you have read all the inputs will fail the level.
$13520918982355 Add a ram block, so the computer can address 256 additional bytes of memory. You need a way to decide which of the 256 bytes inside the ram we are addressing. Select a register and wire it up, so its value always selects the RAM address. When you later want to load or save to the RAM, you will have to first copy the RAM address to this register.


=== levels/ram_block ===

$17142958857584 A OR B
$12901484249817 Can you fit 4 bytes of memory in this limited space?
$14218335256117
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$19282543476901 1
$13765566466116 DON'T SAVE
$15908016538045 VALUE
$16196915566111 0
$14259545926196 A
$12306130287676
In this level you have to build a circuit that 
can [SAVE] or [LOAD] from 4 different bytes of memory.

You are given 1 bit that determines if you are to [LOAD]. Another bit determines if you are to [SAVE] and it comes with a corresponding value.
Additionally, you have 2 address bits. 

With 2 bits, there are 4 combinations, one for each byte of memory in this level.
[i][tip]Join wires in the middle and use right angles or this will be a mess.[/tip][/i]
[i][tip]Spacebar rotates components.[/tip][/i]
$16217965518477 B
$10891070331034 B
$18084166025569 Nothing
$13082830776248 DON'T LOAD
$17473197268827 LOAD
$13555908976270 0 OR 1
$10311371309532 SAVE
$16925432534232 LOAD
$13644027370563 Load
$12933801309767 A
$12291627335021 SAVE


=== levels/byte_less_i ===

$16755383054285 [center]Determine if the first input is less than the second.[/center]
$19006843777401 Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]SIGNED[/color].


=== levels/bit_inverter ===

$15769391111364 When "Invert" is [ON], output the opposite of "Value". Otherwise, just output "Value" as is.
$15272914096446 This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527 Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$16125025706490 Hmm, perhaps you have studied momory a little bit too well...
$12338758521470 This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$13224963076378 We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/and_gate_3 ===

$14788981567936 Create an AND gate with 3 inputs.


=== levels/byte_toggle ===

$19935950225431
Create a component that switches an input byte on or off.
If you get stuck, try [color=#e63e5b][url=byte_switch]this hint[/url][/color].


=== levels/saving_bytes ===

$10633476398156
Create a circuit that can [SAVE] or [LOAD] a byte.

When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.

$15510981129613 LOAD
$13502950630653
[color=#ff9800]None
0
0[/color]
$19109563882664 DON'T LOAD
$16372198430230 SAVE
$11467279617581 SAVE
$15498440508450 Do nothing
$10080722944246 DON'T SAVE
$18873598212433 LOAD
$15582618410991 LOAD and SAVE


=== levels/maze ===

$13225915898937
If you choose to go on to the rest of the levels I will teach you about ram, the stack and function calls and you will get to solve more interesting challenges like this one.
		
But first you would have to build a better computer. [color=#e49f44]OVERTURE[/color] was good as a first machine, but it is clumsy and programs get very messy. To solve the challenges I have for you without pulling all your hair out, you will need something more expressive, the [color=#e49f44]LEG[/color] architecture.
$17275059688693 Congratulations, you won the competition! An amazing achievement!
$13741358519166 The fabled maze. If you solve it you win the competition!
$11103446544344 On the other hand, you could also retire, be proud and enjoy your reward of not being eaten.
$19331074553774
Write an algorithm that gets the robot from the start to the exit. 

This level is hard, you probably want to write down the pseudocode for your algorithm before you implement it.

Use [color=#e63e5b][url=maze]this hint[/url][/color] if you get stuck.

[tip]Remember you can't use immedate values larger than 63, a common mistake is to try to jump to a label further down than the 63rd byte.[/tip]


=== levels/negative_numbers ===

$12574817679356
We need a way to have negative values in bytes. The scheme we have been using so far can represent all numbers from 0 to 255 using a byte. This scheme is called "unsigned", since it only deals with positive numbers.

We need a scheme that allows negative numbers, normally referred to as a "signed" representation. 

Additionally, it would greatly simplify future circuits if the representation works with the adder you already made. 
$17231048881956 To know the difference between things, you need subtraction. To get subtraction, first you need negative numbers.
$19118970740682
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).


=== levels/robot_race ===

$15403032472607 Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959 This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== levels/byte_constant ===

$12641789008694 Create a circuit that always outputs the number 164.


=== levels/any_doubles ===

$16587030847545 Because we are so technologically advanced we have machines fold our socks. Unfortunately the circuit that detects sock pairs broke on the machine.
$14373083988184
This level has 4 inputs. 
Output [ON] when 2 or more of them are [ON].

[tip]Don't overthink this level.[/tip]


=== levels/call_ret ===

$15840165316981
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.

$19416009887091
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=termonology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$19369640789869 Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.
$15463931654475 [center]Add "call" and "ret" instructions[/center]


=== levels/double_buffer ===

$17366913897135 Construct a circuit that outputs the same as the input, just delayed by 2 ticks.
$17497477227061
In the last level you unlocked the Delay Line. It outputs its own input, just 1 tick late.

[img]dialogue/delay_buffer.png[/img]


=== levels/push_pop2 ===

$10062117579269 Add the stack to your computer
$14685569269160
In this level you are supposed to add the stack to your computer and write the program that solves the level.
When the input is 0, you should [color=#e49f44]pop[/color] a value off the stack and output it. When the input is not 0, you should [color=#e49f44]push[/color] it on the stack.


=== levels/odd_ticks ===

$18510295620397 Output [OFF] on the even ticks and [ON] on the odd ticks.
$16987046679863 In a previous level you learned how we don't allow circular dependencies. Now you must learn the one exception.
$16037516781370
Square pins in the game never affect the output in the same tick. They therefore never cause circular dependencies.
	
	[img]dialogue/delay_buffer.png[/img]
$17588119878416
The delay line is allowed to depend on its own input. This is because its input does not influence the rest of the circuit until next tick.
	
[img]dialogue/delay_buffer.png[/img]


=== levels/byte_adder ===

$16888130664370
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173 Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== levels/tick_tock ===

$17701404772563 Add 1
$17940006660359 Count
$17263901743088
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$17883663978196 Overwrite
$19407121413983 ACTION
$10555159894041
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== levels/saving_gracefully ===

$14295883660596 VALUE
$14950983012226 SAVE
$14837033157870 ACTION
$12474728041023
The Delay Line allows us to use a value 1 tick later.

We need to make a component that allows us to use a value whenever we want, regardless of how many ticks later.
We call such a value [color=#e49f44]saved[/color].
$13045361823397 DON'T SAVE
$13740696609075
In this level you have 2 inputs.
Only if the first input is [ON], update the [color=#e49f44]saved[/color] value.
The second input is the value to be [color=#e49f44]saved[/color].

Always output what is currently [color=#e49f44]saved[/color].


=== levels/turing_complete ===

$15326252036920 Before, only code could influence memory, now memory must influence code. With the addition of conditional logic, our computer can run any algorithm, and calculate anything calculable.
$16583885726240 Yes you did it! I thought you were just this odd looking hairless ape creature, but you actually built a real computer! Amazing.
$10510746154639 At tick 1 the program should load address 1.
$10317244906317 No program found
$14587485007736 Until this point all possible programs have been confined to running in order byte by byte.
$19649119273248
The final thing we need to add is a mechanism for changing the program counter through [INSTRUCTIONS] when certain conditions are met.

When the two largest bits are [ON][ON], we are in condition mode. In condition mode, the value in REG 3 is compared against the conditions defined by the lowest 3 bits in the instruction. If the condition is true, we overwrite the counter to the value in REG 0.
Conditionally changing the counter means we can skip [INSTRUCTIONS] based on conditions or have [INSTRUCTIONS] run in a loop.

Conditions:
[OFF] [OFF] [OFF] Never
[OFF] [OFF] [ON] If [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] If [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] If [color=#e49f44]REG 3[/color] ≤ 0 
[ON] [OFF] [OFF] Always
[ON] [OFF] [ON] If [color=#e49f44]REG 3[/color] ≠ 0 
[ON] [ON] [OFF] If [color=#e49f44]REG 3[/color] ≥ 0
[ON] [ON] [ON] If [color=#e49f44]REG 3[/color] > 0

These conditions correspond to the condition component that was saved in the component factory.


=== levels/leg_4 ===

$10794262854382
Add if statements to your circuit. For the if statements, the 2 arguments are compared and if the condition is true, the counter is set to a jump address.
	
The previous instructions had the 4 bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, RESULT[/color][/code]

For if statements the bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, JUMP_ADDRESS[/color][/code]

In addition to the previous opcodes, add:
[code][color=#87a8c8]32 IF_EQUAL
33 IF_NOT_EQUAL
34 IF_LESS
35 IF_LESS_OR_EQUAL
36 IF_GREATER
37 IF_GREATER_OR_EQUAL[/color][/code]

Use unsigned less / greater for the comparisons.

Each opcode does what their name implies. For example the following jumps to byte 16 if REG0 is less than REG1: 
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]

$18542005958715 Set the counter increment to 4
$17133561664335 Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$14973719570693 Add a counter to the circuit
$12920514303805 Add 6 registers to the map
$14309211963063 Create a new schematic and add a program with 4 byte output
$16826220977157
 [color=#b72d41][b]TIP:[/b][/color] 
 COPY is just ADD with the second
 argument being 0
$14690660047411 [center]Implement the condition opcodes[/center]
$18994998239232 I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what opcodes to use and so on.


=== levels/leg_1 ===

$17106892574116 Add a counter to the circuit
$15754373587500 Set the counter increment to 4
$19099471819164
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit watched state" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.

$18860645759682
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]OPCODE[/color]).

Since many operations take 2 arguments (like ADD, OR etc), the second and third byte are for arguments.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$11377431500625 Add 6 registers to the map
$14051336765362 Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$13268807052125 (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$19066122929275 [center]Set up registers and implement the ADD opcode[/center]
$10912834168905
Finally, in this level the [color=#e49f44]OPCODE[/color] is always 0. This means we ADD argument 1 and argument 2 and save the result to the destination.

The value of an argument or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: Register 0
[color=#e49f44]1[/color]: Register 1
[color=#e49f44]2[/color]: Register 2
[color=#e49f44]3[/color]: Register 3
[color=#e49f44]4[/color]: Register 4
[color=#e49f44]5[/color]: Register 5
[color=#e49f44]6[/color]: Counter
[color=#e49f44]7[/color]: Input/Output
[/code]

In the next level you will implement more [color=#e49f44]OPCODES[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].


$10922418807673 Argument 7 means read from input, but input is not enabled.
$18769284297247 Create a new schematic and add a program with 4 byte output


=== levels/circular_dependency ===

$16336401898647 Test 1/2
$13880985462901 Make a circuit where the input of a component depends on its own output
$18010308863615
Create a "circular dependency". This is a circuit where the input of a component relies on its own output. In a circular dependency situation, it is not possible to determine the output of a component, because you would first need to determine the input, which relies on the output and so on (hence the "circular").

This state is normally not allowed in other levels, but in this level the goal is to create it, so you understand what it is before going forward.
$13520037133129 I am not sure it benefits the students, but teachers love it.
$11316928751185 In our education system we traditionally teach by tricking students into doing the wrong thing and then teasing them.


=== levels/divide ===

$16412715945615 [center]Divide the two numbers[/center]
$14525870461271
Integer divide two numbers to find the quotient and the remainder. Consider the fraction 7/3. 3 goes into 7 2 times and 1 is left over. Here 2 is called the [color=#e49f44]quotient[/color] and 1 is called the [color=#e49f44]remainder[/color].
In this exercise, you are first given the numerator (7 in the example) and then the denominator (3) and you are then expected to output the quotient (2) and then the remainder (1).


=== levels/buffer ===

$10260210687588 [center]Test 2: Left input is [img]dialogue/on.png[/img], right output should be [img]dialogue/on.png[/img].[/center]
$13309706297402 [center]Test 3: Right input is [img]dialogue/on.png[/img], left output should be [img]dialogue/off.png[/img].[/center]
$17005228759908 [center]Make sure [img]dialogue/on.png[/img] can only flow from left to right.[/center]
$18349621873762 [center]Test 1: Both inputs are [img]dialogue/off.png[/img], neither side should turn [img]dialogue/on.png[/img].[/center]
$15504762262759
This level starts with 2 special components. They simultaneously act as input and output.

Make sure the signal flows only from left to right. There are 3 tests.

[b]Test 1[/b]: Both sides will be [OFF].

[b]Test 2[/b]: The left side input will turn [ON] and the right side should be [ON].

[b]Test 3[/b]: The right side output will turn [ON] and the left side should be [OFF].


=== levels/flood_predicter ===

$13739681561355 Total volume: 
$19185457941725 Good news, we want to turn earth into an exotic water park!
$18940654086036 We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652 Hit ENTER to show water
$12881972193444
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== levels/dance ===

$14975070588197
We all like the way Robot moves on the dance floor. That's why we want him to lead our dance team. 
	
The only problem is to make him come up with original dance sequences. How do you make creativity out of deterministic logic you ask?

The answer pseudo random number generators.
$15955150920362
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.

In the algorithm below, "shl 1" means shift left once, "shl 2" means shift left twice and "shr 1" means shift right once.

[b]8 bit xorshift RNG:[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Next output next_seed mod 4, to move the robot. Finally use next_seed (before mod 4) as the seed to get the next number in the dance sequence and repeat.

(Notice the initial seed will never be 0)


=== levels/component_factory ===

$17077079648771 Components can be added, renamed or deleted using the level save system.
$19551383617326
Welcome to the component factory, the circuits you create in here will be usable as components in architecture levels.
The circuitry you create defines the behavior of the component and the layout defines its shape.
$12516102012088 This component has no area and will not be usable in levels. Place components on the map to give it area.
$14712417427860 Since this level is a tool and not a challenge, you can go to the level map and continue on when you want.
$15549447390000 2 input/output components are in the same square. The custom component will be unusable since 2 pins can't overlap.


=== levels/ai_showdown ===

$14940806461794
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678 NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012 This time he has taken over the control room and holds the captain hostage.


=== levels/multiply ===

$14622683750375 Bit 2
$14957949958941 What you did here was actually multiplying two 4 bit numbers. We had the intern scale it up to bytes instead.
$17331397914567 Bit 1
$19136817138607 [center]Multiply the 4 bit numbers[/center]
$13232094477834 Bit 3
$13549246864135 Bit 0
$15857218442751 Bit 1
$18132100348781
 [color=#b72d41][b]TIP:[/b][/color] 
 Create nested components in the
 factory by changing the "nesting 
 level" in the file menu.
$14533861483435 Multiplying two 4 bit numbers gives you a 8 bit number. Build a circuit that does this.
$10430040077737 Bit 3
$10274387271390 Bit 0
$16301538038805 Bit 2


=== levels/first_level ===

$12508086025944
We are testing you.

The rules are simple, build a functional computer or you will be eaten. Good luck.
$16321577947087 Congratulations, you have been abducted!
$19257730429557
A signal flows from the "IN" component to the "OUT" component.
In the upper left corner under "input" there is a green icon, 
click on it to turn the "IN" component off. 
$17675121574388 Notice that the OUT component is turned off.\nThis is because the signal stopped flowing from the IN component.


=== levels/binary_programming ===

$11540713506719
You are now free to change the program of your computer.
Click the edit icon on the program component to start programming.
$19281970848639 [center]Add 5 to the input.[/center]
$17770257567603 So in the meantime we will have you help out on the ship a little.
$19446152707984 Click on the edit memory icon on the program component to start programming your computer. Your computer should read an input, add 5 to it and output it again (no need to worry about overflow).
$12078933051174 But since you don't know how to program it yet, you are not quite ready for that.
$11074247151096 Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542 You have built your computer, but to win the competition you still have to finish the maze.


=== levels/leg_3 ===

$14060810229477 Add 6 registers to the map
$14960344494328
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the opcode. We can do that in the following way:
	
When the 8th bit of the opcode is [ON], use argument 1 as an immediate value, instead of as a register address.
When the 7th bit of the opcode is [ON], use argument 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		

$19338533633006 Set the counter increment to 4
$15197362332657 Create a new schematic and add a program with 4 byte output
$18004215603701 Add a counter to the circuit
$10141611261952 [center]Implement immediate values[/center]


=== levels/delay_level ===

$19986989895202
All components have a delay. And in a circuit, the total delay is determined by the slowest path. This means you normally want to put things in parallel.
In this level you must prove that you understand this concept.
$11246430085016 Note, you can see the delay path by clicking the hour glass in the upper right corner.
$12817338693402 The delay of any component is ultimately derived from the delay of the nand gate, which has a delay of 2. Build a circuit with a delay of 6 and a nand cost of 5.


=== levels/computing_codes ===

$14458828731919
Time to merge in the "Arithmetic Engine" circuit you made previously with the register circuit. The calculation circuit was saved in the component factory and can now be added as a component. If you forgot which pin does what, check the circuit in the component factory.

Use the decoder you built to figure out if we should copy between registers or do calculations. Here are the 4 different modes again:
[OFF][OFF] Immediate
[ON][OFF] Copy
[OFF][ON] Calculate
[ON][ON] Condition

For this level you only have to worry about the copy and calculate mode, check [INSTRUCTIONS] in the top panel for the details. When in calculate mode, take [color=#e49f44]REG 1[/color] and [color=#e49f44]REG 2[/color] as inputs, and save the result in [color=#e49f44]REG 3[/color].

[tip]Don't forget the 3 bit decoder component has a disable bit.[/tip]
$13013863429580 For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== levels/push_pop ===

$19245209470436 Create a stack
$12227209887733 Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
$15662660252584 Do nothing
$18761197388580 In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.


=== levels/circumference ===

$11331851878040 Also you now have access to assembly programming. It allows you to add names for instructions, so you can for example type "add" instead of inputting 68.
$11023157447564
2×π×r

r is the input.
And you can approximate π as 3.

Send the answer to output when it has been calculated.
$15260627694444 In order to calibrate said laser, we want you to calculate the circumference of the asteroids using an advanced equation.
$12669851602178 [center]Calculate the circumference of the asteroids[/center]
$16954408093587 On our ship we naturally shoot incoming asteroids with lasers.


=== levels/alu_1 ===

$15865646260225
 [color=#b72d41][b]WISDOM:[/b][/color] 
 Pain is temporary, glory is 
 forever.
$17594613477534
Create a device that can OR, NAND, NOR or AND two inputs. The third input will be the [INSTRUCTION]. An [INSTRUCTION] is just what we call the number that determines what to compute.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Also you can't move the red components in this level, for reasons that will be revealed later.


=== levels/signed_negator ===

$10866019808027 For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click "+255" located in the top panel.
$10400106910274
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
For example 4 negated would become -4. -9 negated would become 9.


=== levels/byte_and ===

$15885763626223 Create a circuit that ANDs two bytes bitwise.


=== levels/byte_mux ===

$18296416014178 When the bit selector input is [OFF], output Byte A, otherwise output Byte B.
$17093993196554
Even though he did not pass our tests we decided to keep the dog. Unlike most earthlings he is fluffy and follows simple instructions well. 

We might want to team you two up, since you compliment each other's shortcomings well.


=== levels/new_nor_gate ===

$11362258372706
Most creatures on Earth are agressive and do not know how to focus.

To succeed you must learn to think logically, while not destroying things.


=== levels/odd_number_of_signals ===

$16173829560311 Using a maximum of 3 components, output [ON] only when an odd number of inputs are [ON].
$18288998816979 This level has a [color=#e63e5b][url=odd_number]hint[/url][/color] you can use if you get stuck.


=== levels/binary_search ===

$11910674853271
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673 You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== levels/alu_2 ===

$16434409050195
Add addition and subtraction to your circuit.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/unseen_fruit ===

$13023474026617
The most noteworthy thing on your planet is the fruit. It is very tasty.

That's why we are having a fruit tasting event in the canteen.
$14259900563789 Scan the conveyor belt for the fruit incoming at regular intervals. As soon as you have see the same kind of fruit twice, turn and press the control panel.
$17070232883226 But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.


=== levels/sort ===

$10160261151833 First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666 We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== levels/or_gate_3 ===

$15448906128695 Create an OR gate with 3 inputs.


=== levels/conditions ===

$12951779797594
This level has a value input and 3 condition bit inputs.

The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
$16407231803964 If VALUE < 0 output [img]dialogue/on.png[/img]
$16742265812068 Regardless of VALUE output [img]dialogue/on.png[/img]
$17616699231679 If VALUE > 0 output [img]dialogue/on.png[/img]
$16632557438774 If VALUE ≠ 0 output [img]dialogue/on.png[/img]
$18234235689107 If VALUE ≥ 0 output [img]dialogue/on.png[/img]
$12429396872036 Regardless of VALUE output [img]dialogue/off.png[/img]
$19014698800906 If VALUE = 0 output [img]dialogue/on.png[/img]
$13680487623452 If VALUE ≤ 0 output [img]dialogue/on.png[/img]
$12706881725738 Your circuit has been saved to the component factory.


=== levels/test_lab ===

$11038144815919
This level uses programs to test your circuits. When the programs are run, this level checks if the "watched state" behaves the way you expect.

The lab has 2 extra keywords.

The [color=#c54d5e]expect[/color] keyword is used to describe what a value a memory address should hold next tick.

The first number after [color=#c54d5e]expect[/color] is index in the watched state, the second number is the expected value. The watched state indexes are the order the components are connected up in to the program component.

[img]dialogue/watched_state.png[/img]

For example:
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

Here, the first line says that we expect the 2nd watched state slot to hold a value of 4 after the next tick.

All watched state is checked against expectations at every tick. All watched state is expected to be 0 at the start of the program, and expectations for memory components only change as you specifically change the expectations. The one exception are counters, these are naturally expected to increment each tick.

The second special keyword for the lab is [color=#c54d5e]set_input[/color]. With this you can control the input of the computer:
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

You can at any time also (re)import example tests by clicking below:
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]

$15446846177093 Welcome to the lab. Like the component factory, this is not a normal level but a tool.
$16072814175447 Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about circuits, when you are in the middle of solving a programming problem. It is tempting to apply a quick circuit fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!


=== levels/demux ===

$16057674753878 Create a component that can switch a signal between 2 pins.


=== levels/full_adder ===

$17063157033479
In the previous level we added together 2 inputs, this time we add 3. Once again, add the inputs together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== levels/or_gate ===

$12749704931323 You should be happy you get to participate in our glorious tests.
$11472059692644 You get a chance to communicate with very advanced people from the galactic civilization.


=== levels/bigger_demux ===

$19231618567710 With 3 bits of input there are 8 combinations. Make a circuit that selects 1 output for each of the 8 combinations. No more or less than 1 bit should be [ON] at a time.
$14293122338496 We had our intern add a "disable" bit to this component. We were tired of looking at him running in circles and were looking for other pointless and tedious tasks to give him.


=== levels/sandbox ===

$17054292175058 Welcome to the sandbox, here you are free to play around. I have given you 64 bit wires and a few IO components.
$10731996208080 There are also 64 bit versions of the program, the counter, the register and the ram. Notice though, the 64 bit ram takes 1 tick to load.
$19454393978813 The Keyboard lets you directly control your computer, using well... your keyboard
$14434122873489 The Waveform Generator lets you make sounds. I will probably regret giving you this one.
$18405942066048 The Clock gives you the current UNIX time in microseconds.
$10451578314373 The Console Screen lets you draw characters to a screen (see manual for ascii characters)


=== levels/byte_not ===

$14196498898485 Tool making and usage is key in the early evolutionary stages of developing intelligence.
$12982025748137 "NOT" each bit of the byte input.
$10294533225655 Our previous model of brain size being the main predictor of intelligence was naive.
$14958585065722 Therefore the number of arms on a creature is clearly the main predictor of intelligence. Did you know there are sea creatures from your planet with four times as many arms as you and they are doing better in tests?


=== levels/and_gate ===

$15232844525838
Create the circuit that matches the table.
	
[tip]Double click on a component to move it together with connected wires.[/tip]
$15231724707514 I don't want to discourage you, but I think the elephant will win the competition. No offense but your brain is tiny in comparison.


=== levels/constants ===

$17098439090371
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== levels/byte_or ===

$10368115829346 But actually it is OK because you lived good lives in the wild and we don't let the meat go to waste.
$15923734370936
OR each bit of the input bytes and output the result.

For example:
[code]
INPUT 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
INPUT 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
OUTPUT  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]

$15226896485081 You may think it is unethical to eat all the earthlings that don’t win the competition?


=== levels/program ===

$16693098943939
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479 The program is still outputting the first instruction. Did you hook up a counter?


=== levels/towers ===

$13757925963562 Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686 We need you to help clean up the basement.
$15855497886737
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== levels/wide_instrucitons ===

$13709034294291 Save on even tick, output both bytes on odd ticks
$17693995237077 Output both bytes
$19068760748550 Output 0 on even ticks
$19203973423116 Create a device that saves the program output on even ticks, and outputs both bytes on odd ticks.
$17409169138995 Save the byte


=== levels/2nd_tick ===

$14355963067874 Output [ON] on the second tick only.
$17526582195506 As you know these tests culminate in building a functioning computer.
$15726318553190 This is the main reason we don't eat you afterwards.
$19277843280528
 [color=#b72d41][b]TIP:[/b][/color] 
 You can select a component with 
 its pins by double clicking it
$15296208528991 Species that are capable of finishing are considered sentient by law.


=== levels/byte_less ===

$11252365204151 Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
$11632471752785 [center]Determine if the first input is less than the second.[/center]


=== levels/always_on ===

$17712385236630 Create a circuit that is always [ON].


=== levels/leg_2 ===

$19693461238792 Set the counter increment to 4
$18189600217529 [center]Implement the OPCODE instructions[/center]
$13450117997204 Add a counter to the circuit
$13870568875751 Create a new schematic and add a program with 4 byte output
$10303603301757
Implement the following opcodes:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The opcode NOT ignores the second argument.
$17495651785164 Add 6 registers to the map


=== levels/capitalize ===

$14894954428144
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810 We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837 Input: 
$11201813578269 Output: 


=== levels/byte_xor ===

$19636386696963 Create a circuit that XORs two bytes bitwise.


=== levels/byte_equal ===

$17156565273196 Output [ON] when both inputs are the same.


=== levels/binary_racer ===

$16076448195257 This level is my favorite pastime. Converting decimal into binary under time pressure.
$19111664765554
Toggle the bits in the level panel so they add up to the decimal number in the question.

You must reach level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)


=== levels/spacial_invaders ===

$19967210826470 Be aware that the laser can only shoot when there are no other laser beams already in flight.
$16294185981398 The cargo hull has become infested with space rats.
$11505369795084 Check [color=#e49f44][url=the_robot]robot page[/url][/color] for instructions on how to program him. There is a link to that page in the program editor as well.
$10515630949378 We have hooked your machine up to our advanced robot and we want you to program it to shoot the space rats with lasers.


=== levels/xor_gate ===

$14093358515620 This is also known as an XOR gate. This level is difficult, so don't be discouraged if you don't get the answer right away.
$19182751521677 Last level you built a circuit that was [ON] when we were at the second tick. This level build a circuit that is [ON] when we are at the second OR third tick.


=== levels/xor ===

$12758156517177 Using the instructions of your computer, read the input twice and XOR the two values together
$16047615798435 [center]Read the input twice and XOR the bits of the two inputs[/center]


=== levels/mod_4 ===

$16810715868480 [center]Calculate modulo 4 of the input.[/center]
$17375862136921
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.


=== levels/not_gate ===

$19085882338208 [b]Instruction[/b]\nRight click to deselect
$10042327259531 Now that you unlocked the NAND gate, it is time for you to build a circuit.
$14042842216181 Last level you made the table that described the circuit. In this level you build the circuit that matches table.
$10604720087324 [b]Instruction[/b]\nBuild a circuit that makes the table correct.\nClick [i][/i] (Next tick) in the upper left corner to test each combination of inputs.\nYou win the level once both combinations have been tested correct.
$19798729463813
Using NAND gates, build the NOT gate

Using: [b]NAND gate[/b]
[code]INPUT 1: [OFF][ON][OFF][ON]
INPUT 2: [OFF][OFF][ON][ON]
OUTPUT:  [ON][ON][ON][OFF][/code]

Build: [b]NOT gate[/b]
[code]INPUT 1: [ON][OFF]
OUTPUT:  [OFF][ON][/code]

$18442122157391 [b]Instruction[/b]\nDeselect the component by clicking the background
$12880883686501 [b]Instruction[/b]\nClick on the NAND component on the top right side of the screen and place it
$18780831606716 [b]Instruction[/b]\nClick and drag on the board to add a wire


=== levels/bit_adder ===

$13109388951000 We measure the universe with numbers. So your machine must learn to count.
$16564356062672
Treat the inputs as [ZERO] or [ONE] depending if they are [OFF] or [ON]. Add them together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== levels/byte_shift ===

$16023356915123
The task in this level is to shift the first input to the left by the value given in the second input. The second input will never exceed 7.

$10598344098990 [center]Shift the first input left by the number of places given by the second[/center]
$16216408139965
To [color=#e49f44]shift[/color] a value 1 left just means moving all the bits in a byte to the left by 1 position.
For example: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]


$18137790657923 In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.
$18518173140953 I recommend that you add [color=#e49f44]shift left[/color] and [color=#e49f44]shift right[/color] to your hardware for future levels.


=== levels/registers ===

$10661964231175 I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$15888345020710
In this level you need to create a circuit which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color]. 

The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color]. 

Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$14823499195861 Open "Instructions" in the top bar
$14108238519744 Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593 Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== levels/double_number ===

$19766257822639
The input and output of this level are using bytes instead of bits. One of the two new components you are given takes a byte and splits it into bits and the other does the opposite.

Using those components, figure out how to double the input number (up to 127).


=== levels/counting_signals ===

$10724914203078
The output component of this level is a binary counter where the first 3 pins correspond to 1, 2 and 4.
Use the binary counter to count the number of signals.

Check [color=#e63e5b][url=counting_signals]this hint[/url][/color] if you get stuck

[i][tip]The solution for this level is not very neat and requires more components.[/tip][/i]

$10881918807029
 [color=#b72d41][b]TIP:[/b][/color] 
 There is no shame in using
 pen and paper


